---
title: 网络通信的可靠性保证方法
date: 2024-04-29 13:34:12 +0800
categories: [企业架构设计]
tags: [架构设计]
---

## 重试机制

使用消息队列可以实现接口请求的异步重试机制。

基本思路是:
- 接口请求发送失败后,将请求信息封装为消息,发送到请求重试的队列中。
- 消息消费者从队列中获取失败的请求,根据策略进行重试。
- 重复重试直到成功、重试次数用尽或其他终止条件。
- 成功后将消息移除队列,失败则保留消息供再次重试。

主要步骤:
- 创建请求重试队列,如“request.retry.queue”
- 接口请求失败后,生成重试消息,发送到队列
- 消费者启动线程从队列中取消息重试
- 根据重试策略进行定时重试或最大重试数
- 成功则确认消息,失败则重新入队

使用消息队列进行重试有利于:
- 异步重试,不阻塞主线程
- 可靠地完成重试任务
- 灵活控制重试策略

## 数据加密

B2C公网环境使用HTTPS已经能很好地保证数据安全，业务功能依据具体需求进行敏感数据加密或脱敏即可。B2B服务开放OpenAPI时，涉及多端授权，需要通过密钥或证书对消息内容进行加签、验签，从而保证双方通信消息的安全性和真实性。

基本思路是
- 系统为下游服务创建clientId、clientSecret，密钥在两端都保存。
- 向外部服务发送请求时，平台对消息体进行加签/加密，外部服务对消息验签/解密。
- 同样，平台接收外部服务请求时，外部服务对加签/加密，平台对消息体进行验签/解密。
![alt text](/assets/img/20240429/image-4.png)

#### 非对称加密+对称加密
在安全系数要求较高的接口中，通常会采用RSA等非对称加密手段，但在加密数据体较大时RSA加密会导致包体膨胀和性能下降的问题，此时可采用非对称加密+对称加密方式。

![alt text](/assets/img/20240429/image-5.png)

## 幂等校验

对于需要进行数据修改的功能，接口必须进行幂等性校验。

### 防重表
数据库防重利用数据表唯一索引的特性，当并发时新增报错时，再查询一次，数据已经存在，就避免了脏数据的新增。但注意，不要将 uuid 作为索引字段，其大小和类型对于索引而言都会导致速度非常慢。

常见的场景，比如博客 / 微博系统点赞，一个用户对一个微博点赞，就把用户 id 与该博文 id 绑定，后续该用户再对该博文点赞就无法插入。再比如金融账户，可以通过在账户表中增加唯一索引来存储用户 id，即使重复操作一个用户也只能拥有一个账户。

### 分布式锁
防重表可以使用分布式锁代替，比如Redis。订单发起支付请求，支付系统会去Redis缓存中查询是否存在该订单号的Key，如果不存在，则向Redis增加Key为订单号。查询订单支付已经支付，如果没有则进行支付，支付完成后删除该订单号的Key。通过Redis做到了分布式锁，只有这次订单订单支付请求完成，下次请求才能进来。相比去重表，将放并发做到了缓存中，较为高效。

### 状态标识
利用业务本身状态判断。常见的场景如三方支付系统在用户支付完成后向应用系统发送付款回调，业务系统更新订单状态标识为已付款，后续重复收到付款回调则忽略请求。

### token 令牌机制
token 机制是使用范围最广泛的一种幂等设计。虽然实现方式有很多种，但核心思想就是每次操作都生成一个唯一 token 凭证，服务器通过这个唯一凭证确保同样的操作不会被执行多次。

这个方案适合简单业务场景，如接口防抖，不适合用于安全性一致性要求较高的场景。
