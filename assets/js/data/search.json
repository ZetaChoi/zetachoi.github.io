[ { "title": "软件设计指南", "url": "/posts/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97/", "categories": "", "tags": "", "date": "2025-07-09 00:00:00 +0800", "snippet": "1 知识体系概述graph LRA[系统设计]B[结构化分析和设计]C[面向对象分析和设计]D[OMT]E[OOSE]F[Booch]G[UML]A --&gt; BA --&gt; CC --&gt; D &amp; E &amp; F &amp; G系统设计的主要内容包括新系统总体结构设计、代码设计、输出设计、输入设计、处理过程设计、数据存储设计、用户界面设计和安全控制设计等。目前，已存...", "content": "1 知识体系概述graph LRA[系统设计]B[结构化分析和设计]C[面向对象分析和设计]D[OMT]E[OOSE]F[Booch]G[UML]A --&gt; BA --&gt; CC --&gt; D &amp; E &amp; F &amp; G系统设计的主要内容包括新系统总体结构设计、代码设计、输出设计、输入设计、处理过程设计、数据存储设计、用户界面设计和安全控制设计等。目前，已存在的多种系统设计方法，常用的设计方法有以下两种。（1）面向数据流的结构化设计方法（SD）。（2）面向对象的设计方法（OOD）。结构化分析与设计方法是一种面向数据流的需求分析和设计方法，它适用于分析和设计大型数据处理系统，是一种简单、实用的方法，曾获得广泛的应用。结构化分析方法的特点是利用数据流图来帮助人们理解问题，对问题进行分析。面向对象分析的目标是开发一系列模型，这些模型描述计算机软件，当它工作时以满足一组客户定义的需求。对象技术凭借其对数据的高效封装及良好的消息机制，实现了高内聚、低耦合的系统设计，成了现代软件设计的主流方法学。面向对象技术的流行，演化出了数十种不同的 OOA 方法，其中比较流行的方法包括 OMT、 OOA、 OOSE、 Booch 方法等，而OMT、 OOSE、 Booch 最后则统一成为 UML。结构化分析与面向对象分析方法之间的最大差别是：结构化分析方法把系统看作一个过程的集合体，包括人完成的和电脑完成的；而面向对象方法则把系统看成一个相互影响的对象集。一、架构设计架构设计是系统的顶层规划，旨在定义系统的整体结构、组件划分、交互机制及技术选型，确保系统具备高可用性、可扩展性与可维护性，支撑业务目标的实现。在大量的可能结构中，可以使用不同的结构来实现同样的功能性，即功能性在很大程度上是独立于结构的，因此架构设计应关注对结构的选择，在满足功能属性的前提下，满足质量属性。参考：《软件架构实践（第三版）》《系统架构设计师教程（第四版）》flowchart LR A[架构需求分析] --&gt; B[架构设计] B --&gt; C[架构模式选型] C --&gt; D[技术和框架选型]1 架构需求分析1.1 识别关键架构需求关键架构需求 （architecturally significant requirement，ASR）是显著影响架构中的结构选择的需求。ASR 通常分为四类。 约束：给定或选定的不可更改的设计决策 质量属性：外部可见特性，表征系统在特定环境下的运行情况 影响较大的功能需求：架构设计需要特别注意的特性和功能 其他影响因素：时间、知识、经验、技术、办公室政治、架构师技术特长等识别关键架构的核心目标是确认质量属性。质量属性会在整个设计过程中用来指导挑选技术、结构、模式，以及评估设计决策的合理性。挖掘关键架构需求的方法： 阅读PRD 头脑风暴 利益相关访谈 假设清单 开展质量属性研讨会1.2 描述质量属性质量属性主要分为 6 种，其他的质量属性一般可纳入这几个属性中： 可用性 可修改性 性能 安全性 可测试性 易用性质量属性描述了软件系统的外部可见特性以及我们对系统运行的期望，它也定义了系统执行某些操作时的表现（质量需求）。质量属性场景利用质量属性场景来明描述质量属性，可赋予抽象的属性（可扩展性、可用性、性能等）具体的含义（业务场景、需求），映射关键架构需求，并提供度量标准。 刺激源：生成该刺激的实体（人、计算机系统或其他激励器）； 刺激：刺激到达系统时可能产生的 影响（即需要考虑和关注的情况）； 环境：该刺激在某条件内发生。如系统可能正处于过载情况； 制品：系统中受刺激的部分（某个制品被刺激）； 响应：刺激到达后所采取的行动； 响应度量：当响应发生时，应能够以某种方式对应其度量，用于对是否满足需求的测试。 注：在架构需求分析阶段，应完成质量属性描述（刺激源、刺激、环境、制品），实现战术（响应）及度量方式（响应度量）则在设计决策阶段完成。示例 - 秒杀场景刺激源：大量用户（人）在电商平台的促销活动期间，同时发起商品下单请求。在 “双 11”“618” 等大型促销活动时，短时间内会有海量用户集中下单。​刺激：系统可能面临服务器负载过高、响应延迟增加、订单处理出现错误甚至系统崩溃等情况，导致用户无法正常下单，严重影响用户体验和平台业务。​环境：促销活动期间，系统处于高并发访问状态，服务器资源（如 CPU、内存、网络带宽等）接近或达到饱和，数据库的写入和读取操作频繁，系统整体压力巨大。​制品：电商系统中的订单处理模块、数据库服务器以及相关的网络通信组件等，这些都是在用户下单请求到达时会受到刺激的部分。​响应：当高并发下单请求到达时，系统采取以下行动：一是使用负载均衡器将请求均匀分配到多个服务器节点，避免单个服务器过载；二是采用消息队列缓存下单请求，进行异步处理，缓解系统瞬间压力；三是对订单处理模块进行限流，限制单位时间内的订单处理数量，保证系统稳定运行。​响应度量：可以通过以下方式进行度量。一是测量系统的响应时间，要求在高并发情况下，订单处理的平均响应时间不超过 2 秒；二是统计订单处理的成功率，确保订单处理成功率不低于 99%；三是监控服务器的 CPU 和内存使用率，保证其使用率不超过 80% 。通过这些度量指标，可以测试系统是否满足高并发下单处理的质量需求。2 架构设计在实践中，每个架构设计决策都至少会提升或抑制一个质量属性。大多数设计决策在提升某些质量属性的同时抑制了其他的质量属性，牺牲某个质量属性换取另一个质量属性。质量属性关系矩阵（“+”代表行属性能促进列属性，“-”则相反）：2.1 可用性设计错误检测 命令/响应：一个构件发出一个命令，并希望在预定义的时间内收到一个来自审查构件的响应，例如远程错误的检测。 心跳（计时器）：一个构件定期发出一个心跳消息，另一个构件收听到消息，如果未收到心期发出一个心跳消息，另一个构件收听到消息，如果未收到心跳消息，则假定构件失败，并通知错误纠正构件。跳消息，则假定构件失败，并通知错误纠正构件。 异常：当出现异常时，异常处理程序开发执行。错误恢复 表决：通过冗余构件（或处理器）与表决器连接，构件按相同的输入及算法计算输出值交给表决器，由表决器按表决算法（如多数规则）确定是否有构件出错，表决通常用在控制系统中。 主动冗余（热重启、热备份）：所有的冗余构件都以并行的方式对事件做出响应。它们都处在相同的状态，但仅使用一个构件的响应，丢弃其余构件的响应。错误发生时通过切换的方式使用另一个构件的响 应。 被动冗余（暧重启/双冗余 /三冗余）：一个构件（主构件）对事件做出响应，并通知其他构件（备用的）必须进行的状态更新（同步）。当错误发生时，备用构件从最新同步点接替主构件的工作。 备件：备件是计算平台配置用于更换各种不同的故障构件。状态再同步：主动和被动冗余战术要求所恢复的构件在重新提供服务前更新其状态。更新方法取决于可以承受的停机时间、更新的规模及更新的内容多少。 检查点/回滚：检查点就是使状态一致的同步点，它或者是定期进行，或者是对具体事件做出响应。当在两检查点之间发生故障时，则以这个一致状态的检查 点（有快照）和之后发生的事务日志来恢复系统（数据库中常使用）。错误预防 从服务中删除：如删除进程再重新启动，以防止内存泄露导致故障的发生。 事务：使用事务来保证数据的一致性，即几个相关密切的步骤，要么全成功，要么都不成功。 进程监视器：通过监视进程来处理进程的错误。2.2 可修改性设计局部化修改在设计期间为模块分配责任，以便把预期的变更限制在一定的范围内，从而降低修改的成本。 维持语义的一致性：语义的一致性指的是模块中责任之间的关系，使这些责任能够协同工作，不需要过多地依赖其他模块。耦合和内聚指标反映一致性，应该根据一组预期的变更来度量语义一致性。使用“抽象通用服务”（如应用框架的使用和其他中间软件的使用）来支持可修改性是其子战术。 预期期望的变更：通过对变更的预估，进行预设、准备，从而使变更的影响最小。泛化该模块：使一个模块更通用、更广泛的功能。 限制可能的选择：如在更换某一模块（如处理器）时，限制为相同家族的成员。防止连锁反应由于模块之间有各种依赖性，因此，修改会产生连锁反应。 信息隐藏：就是把某个实体的责任分解为更小的部分，并选择哪些信息成为公有的，哪些成为私有的，通过接口获得公有责任。维持现有的接口：尽可能维持现有接口的稳定性。例如通过添加接口（通过新的接口提供新的服务）可以达到这一目的。 限制通信路径：限制与一个给定的模块共享数据的模块。这样可以减少由于数据产生/使用引入的连锁反应。 仲裁者的使用：在具有依赖关系的两个模块之间插入一个仲裁者，以管理与该依赖相关的活动。仲裁者有很多种类型，例如：桥、调停者、代理等就是可以提供把服务的语法从一种形式转换为另一种形式的仲裁者。推迟绑定时间系统具备在运行时进行绑定并允许非开发人员进行修改（配置）。 运行时注册：支持即插即用。 配置文件：在启动时设置参数。 多态：在方法调用的后期绑定。 构件更换：允许载入时绑定。2.3 性能设计资源限制 减少处理事件流所需的资源：提高计算效率（如改进算法）、减少计算开销（如在可修改性与性能之间权衡，减少 不必要的代理构件）。 减少所处理事件的数量：管理事件率、控制采样频率。 控制资源的使用：限制执行时间（如减少迭代次数）、限制队列大小。资源管理 引入并发：引入并发对负载平衡很重要。维持数据或计算的多个副本：C/S 结构中客户机 C 就是计算的副本，它能减少服务器计算的压力；高速缓存可以存放数据副本（在不同速度的存储库之间的缓冲）。 增加可用资源：在成本允许时，尽量使用速度更快的处理器、内存和网络。资源调度 先进/先出（FIFO） 固定优先级调度：先给事件分配特定的优先级，再按优先级高低顺序分配资源； 动态优先级调度：轮转调度、时限时间最早优先； 静态调度：可以离线确定调度。2.4 安全性设计抵抗攻击 对用户进行身份验证：包括动态密码、一次性密码、数字证书及生物识别等； 对用户进行授权：即对用户的访问进行控制管理； 维护数据的机密性：一般通过对数据和通信链路进行加密来实现； 维护完整性：对数据添加校验或哈希值；限制暴露的信息； 限制访问：如用防火墙、DMZ 策略。检测攻击一般通过“入侵检测”系统进行过滤、比较通信模式与历史基线等方法。从攻击中恢复 恢复：与可用性中的战术相同； 识别攻击者：作为审计追踪，用于预防性或惩罚性目的。2.5 可测试性设计优化输入/输出 记录/回放：指捕获跨接口的信息，并将其作为测试专用软件的输入； 将接口与实现分离：允许使用实现的替代（模拟器）来支持各种测试目的； 优化访问线路/接口：用测试工具来捕获或赋予构件的变量值。内部监控当监视器处于激活状态时，记录事件（如通过接口的信息）。2.6 可修改性设计运行时战术 任务的模型：维护任务的信息，使系统了解用户试图做什么，并提供各种协助。 用户的模型：维护用户的信息，例如使系统以用户可以阅读页面的速度滚动页面。 系统的模型：维护系统的信息，它确定了期望的系统行为，并向用户提供反馈。设计时战术将用户接口与应用的其余部分分离开来，预计用户接口会频繁发生变化，因此，单独维护用户接口代码将实现变更局部化。这与可修改性相关。支持用户主动操作支持用户的主动操作，如支持“取消”、“撤销”、“聚合”和 “显示多个视图”。2.7 常见设计示例性能设计 缓存策略：采用多级缓存机制，如本地缓存（Caffeine）+ 分布式缓存（Redis），减少数据库查询次数；对热点数据设置合理的缓存过期时间，并使用缓存预热技术，在系统启动时提前加载热点数据到缓存。​ 异步处理：将耗时操作（如订单生成后的报表统计、邮件通知）异步化处理，通过消息队列或异步任务框架（如 Spring Task、XXL-JOB）实现，避免阻塞主线程，提高系统响应速度。​ 数据库优化：合理设计索引，避免全表扫描；对大表进行分区（如按时间、ID 范围分区）；定期清理历史数据，保持数据库性能。高可用设计 多副本部署：每个微服务在 K8s 集群中部署多个副本，通过负载均衡器（如 Ingress Controller）实现流量分发，当某个副本出现故障时，自动将流量切换到其他副本。​ 故障转移：Nacos 提供集群模式，保证服务注册中心的高可用；数据库采用主从复制（MySQL 主从架构）+ 读写分离，主库负责写操作，从库负责读操作，当主库故障时，自动切换到从库继续提供服务。​ 容灾备份：定期对数据库进行全量备份和增量备份，备份数据存储在异地数据中心；对关键业务数据（如订单数据、用户数据）进行多副本存储，防止数据丢失。安全性设计 身份认证与授权：采用 JWT（JSON Web Token）进行用户身份认证，用户登录成功后，服务器生成 JWT 令牌返回给客户端，客户端在后续请求中携带令牌进行认证；基于 RBAC（基于角色的访问控制）模型实现权限管理，不同角色拥有不同的操作权限。​ 数据加密：对敏感数据（如用户密码、支付信息）在传输和存储过程中进行加密处理。传输时使用 HTTPS 协议，通过 SSL/TLS 加密数据；存储时使用 AES 等对称加密算法对数据进行加密，加密密钥安全存储。​ 漏洞扫描与防护：定期使用 OWASP ZAP、Nessus 等工具对系统进行安全漏洞扫描，及时发现和修复 SQL 注入、XSS 攻击、CSRF 攻击等安全漏洞；部署 Web 应用防火墙（WAF），对恶意请求进行拦截。3 架构模式选型参考：《主流技术架构分析》《KTech New Platform 架构原则》4 技术和框架选型参考：《KTech New Platform 技术选型》二、概要设计阶段及主要产出：| 设计阶段 | 产出 || —————— | —————————— || 业务流程建模 | 时序图、状态转换图、补偿机制表 || 系统服务设计 | 服务拓扑图 || 面向对象设计和建模 | UML类图 || 数据库设计 | E-R图 |1 业务流程建模(结构化分析设计)业务流程建模是衔接业务需求与技术实现的核心桥梁，这一阶段的主要目标是了解软件系统的需求和目标，回答系统必须“做什么”，并通过图表业务逻辑关系，为后续的设计阶段提供基准。业务流程建模的主要目标： 消除业务与技术之间的认知鸿沟 识别流程中的阻塞点（Bottleneck）和单点故障（SPOF） 为技术方案提供可验证的输入基准 为测试方案提供可验证的输入基准通常，流程建模的输入来自PRD文档，包括业务流程图、业务规则说明、用户角色矩阵、功能用例清单等。步骤1：绘制时序图，表达主流程时序图主要展示对象之间的交互顺序，通过视图明确系统组件与角色的协作逻辑。 拆解角色与组件 从 PRD 中提取参与流程的实体（如用户、支付系统、库存系统）边界 标注外部系统（如第三方支付）与内部模块（如订单服务）的交互边界 映射时序以用户触发事件为起点（如 “用户下单”），按时间顺序绘制消息传递链条，例如： sequenceDiagramparticipant A as 用户participant B as 订单服务participant C as 支付系统A -&gt;&gt; B: 创建订单 B -&gt;&gt; C: 发起支付 C --&gt;&gt; B: 支付成功B --&gt;&gt; A: 更新支付状态 补充关键元素 在消息箭头上标注业务规则（如 “订单金额&gt; 0”“库存校验通过”），关键节点添加「约束条件」注释 验证消息顺序并补充循环逻辑（如重试机制） 步骤2：绘制状态图，管理实体生命周期状态图通过描述系统的状态和引起系统状态转换的事件，来表示系统的行为，指出作为特定事件的结果将执行哪些动作（例如处理数据等）。步骤如下： 获取业务实体通常实体以名词出现在时序图的流程连线中，如（订单、支付） 状态定义枚举业务实体的最小状态单元（如订单状态：待支付、已支付、已取消、已完成），排除模糊状态（如 “处理中” 需细化为 “支付处理中”“发货处理中”）。 建立状态转换模型绘制状态节点与转换箭头，标注触发事件（如 “用户取消” 触发订单从 “待支付” 到 “已取消”）和前置条件（如 “未支付且未超时”）。 特殊场景处理 并行状态：如 “订单已支付” 与 “物流待揽收” 可同时存在（用 UML「组合状态」表示）。 历史状态：通过「状态日志」记录跃迁历史（如 “已退款→已关闭”）。 stateDiagram-v2 [*] --&gt; 新建订单 新建订单 --&gt; 待支付: 用户提交订单 待支付 --&gt; 支付处理中: 调用支付接口 支付处理中 --&gt; 已支付: 支付成功 支付处理中 --&gt; 支付失败: 接口超时/金额校验失败 支付失败 --&gt; 退款中: 自动触发退款补偿 退款中 --&gt; 已关闭: 退款完成 待支付 --&gt; 已取消: 用户主动取消（未超时） 待支付 --&gt; 已取消: 系统超时未支付（超时阈值=30分钟） 已支付 --&gt; 已完成: 库存校验通过+发货完成 已支付 --&gt; 库存锁定失败: 库存不足（分布式锁竞争） 库存锁定失败 --&gt; 退款中: 触发库存补偿（释放预占库存） 已取消 --&gt; [*]: 终止状态（不可恢复） 已完成 --&gt; [*]: 终止状态（不可恢复） 已关闭 --&gt; [*]: 终止状态（不可恢复）步骤3：建立异常处理矩阵，覆盖边界条件异常处理矩阵通过结构化表格的形式，将 “异常类型 - 触发条件 - 处理措施 - 验证标准” 等要素关联起来，确保边界条件覆盖的完整性和可追溯性。步骤如下： 从时序图中提取所有可能的失败点，枚举异常场景 支付环节：支付超时、余额不足、支付渠道不可用 库存环节：库存锁竞争失败、超卖、库存数据不一致 通用环节：参数校验失败、权限校验失败、网络中断 按优先级分类异常 高风险：支付接口超时（高频发生，阻断主流程，需立即处理） 中风险：库存预占失败（高并发场景偶发，触发补偿流程） 低风险：用户输入格式错误（前端可拦截，影响有限） 设计异常处理策略，输出异常处理矩阵 示例-支付流程异常矩阵： | 异常类型 | 触发条件 | 影响范围 | 处理策略 | | ————– | ————————– | ————– | ———————– | | 支付渠道不可用 | 支付网关返回 503 错误 | 阻断主流程 | 熔断 + 切换备用渠道 | | 金额校验失败 | 订单金额与支付金额不一致 | 阻断主流程 | 返回异常信息 + 记录日志 | | 重复支付 | 同一订单号重复提交支付请求 | 数据一致性风险 | 幂等校验 + 自动退款 | | 银行对账差异 | 支付成功但银行流水未同步 | 数据最终一致性 | 每日自动对账 + 人工调账 |步骤4：设计补偿机制，保障最终一致性通过关联状态图与异常矩阵，识别无法到达终态的异常，设计对应的状态转换和补偿动作，例如：| 异常类型 | 目标状态 | 补偿动作 || ————– | ———— | ——————————- || 支付接口超时 | 支付失败 | 退款补偿 + 释放库存预占 || 库存锁竞争失败 | 库存锁定失败 | 回滚已扣减的用户积分 + 通知运营 |操作要点： 通过状态图识别异常长事务如 “下单 - 支付 - 关闭”，将其拆分为可补偿的原子操作单元，并为每个单元定义正向操作与补偿操作如： 正向：支付成功，支付失败 补偿：退款 选择补偿策略 自动补偿：适用于无人工干预场景（如支付失败后自动退款），需确保补偿接口幂等性（通过唯一事务 ID 防重放）。 人工补偿：适用于复杂异常（如库存差异需人工盘点），设计补偿工单系统，记录补偿进度与操作日志。 stateDiagram-v2退款 --&gt; 补偿重试: 进入延迟队列（重试3次）补偿重试 --&gt; 退款: 重试间隔=10s补偿重试 --&gt; 人工介入: 3次失败，进入死信队列人工介入 --&gt; 关闭: 人工确认退款2 系统服务设计(服务/模块划分)2.1 识别实体名词提取法从业务需求文档（PRD）、用户故事、用例描述等材料中，提取所有具有实际业务意义的名词作为候选实体。例如，在电商系统的需求描述 “用户在商品详情页浏览商品信息，将心仪商品加入购物车，下单后生成订单并进行支付” 中，可提取出 “用户”“商品”“商品详情页”“购物车”“订单”“支付” 等候选实体。在此过程中，需排除无独立业务价值的名词，如 “页面” 这种纯技术概念，而聚焦 “商品” 这类承载业务数据的服务实体。角色抽象法梳理核心业务流程，分析流程中参与交互的角色和对象，并将其抽象为实体。以订单创建流程为例，涉及用户提交订单、订单服务处理订单、库存服务校验库存、支付服务完成支付等环节，可从中识别出 “用户”“订单服务”“库存服务”“支付服务” 等实体。对于流程中具有特定职责的角色，如 “库存管理员”，若其业务操作与库存服务紧密相关，可将其职责整合到 “库存服务” 实体中，避免过度细化。限界上下文分析法在领域驱动设计中，根据业务领域的边界，划分不同的限界上下文，每个上下文内包含相关的实体。在电商系统中，可划分为 “用户域”“商品域”“订单域”“支付域” 等。在 “订单域” 中，核心实体为 “订单”，同时包含 “订单明细”“订单状态” 等相关实体；而 “支付域” 则围绕 “支付记录”“支付方式” 等实体展开。通过限界上下文，明确各实体的职责范围，避免不同领域的实体混淆。参考现有系统或行业标准若存在类似的现有系统，可参考其已有的实体设计；同时，借鉴行业通用标准和规范，确定符合业务领域的实体。例如，在金融行业的支付系统设计中，可参考银联、支付宝等支付机构的接口规范，确定 “支付”、“交易” 等标准实体；在电商行业，可依据行业惯例确定 “商品”、“库存” 等实体。2.2 划分服务划分原则1) 单一责任原则（SRP+）每个服务只处理一个完整业务域（如订单域、用户域）禁止出现跨领域交叉（如支付服务不应包含库存扣减逻辑）2) 自治性原则服务可独立开发、部署、扩展数据自治：服务拥有私有数据库，禁止直接跨库查询3) 通信效率原则高频交互的功能应合并到同一服务跨服务调用链不超过3跳（如 A-&gt;B-&gt;C 已达上限）划分方法 按照业务模块划分 按照事务划分(事务一致性分析) 按照性能热点划分：划分后是否会存在性能问题。比如链路过长、调用接口过多、数据量级同步过大等 按照成本划分：是否会产生额外的沟通交流、运营成本 按照质量划分：是指在业务领域划分后，是否会产生质量风险。比如数据同步风险、流量过大风险等争议解决方案案例：商品评价功能划分| 归属服务 | 优点 | 缺点 || ————— | ————– | ———————— || Product-Service | 信息聚合度高 | 评价的读写影响主流程QPS || Review-Service | 独立、扩展性强 | 需跨服务获取商品基础数据 |决策路径： 是否与主实体强绑定？ → 是 → 合并到主服务 是否有独立业务规则？ → 是 → 独立服务 QPS是否超过标准？ → 是 → 独立服务2.3 确定模块之间交互方式 同步调用：用于对实时性要求高且响应时间短的场景，例如用户登录验证。 异步调用：可确保不会因为某个通信环节阻塞整体流程，并借助重试机制达到最终一致性。通常而言，应优先选择异步调用设计，确保不同服务间低耦合。但对于逻辑强依赖的两个服务（如登录验权服务强依赖用户账户服务），一个服务的异常会导致整体流程失败，则无法发挥异步调用的优势，选择同步调用设计即可。2.3.1 同步调用 在微服务架构中，模块间通过RPC框架进行同步调用。 graph LRA[Service-A]B[Service-B]A --&gt; |RPC|BB -.-&gt; A 非微服务架构及对外部服务的调用则可采用HTTP接口实现，但需要注意设计失败补偿机制。````mermaidgraph LR subgraph Service-A Node1[Bussniss] –&gt; Node2[Http Handler]Node2 -.-&gt; |失败重试|Node2endNode2 –&gt; |Http|B[Service-B]#### 2.3.2 异步调用主要利用MQ、Kafka、Redis等中间件实现异步通信。![alt text](/assets/img/20250709/image1.png)### 2.4 绘制服务拓扑图示例：```` mermaidgraph TD A[用户服务] --&gt; |RPC|B[订单服务] B --&gt; |RPC|C[商品服务] B --&gt; |RPC|D[库存服务] B --&gt; |Http|E[支付服务] F[物流服务] --&gt; |MQ|B B --&gt; |MQ|F3 面向对象设计和建模面向对象设计流程可概括为：flowchart LR A[识别对象] --&gt; B[定义类职责] B --&gt; C[建立类间关联关系] C --&gt; D[应用设计模式]3.1 识别对象即从业务需求、用户场景中识别和提取关键的业务概念、实体、规则和关系，并将其抽象为面向对象模型的基础元素（如类、对象、属性等）。为后续的设计（如UML类图、数据库设计等）提供基础。主要的技巧有以下两种：名词短语分析法通读PRD、用户故事，标记所有名词（实体）与动词（操作）： 实体类：订单、用户、商品、库存、支付记录 边界类：用户界面、第三方支付接口 控制类：订单处理器、支付控制器同时排除无关概念，如 “系统管理员” 若仅作为背景角色，不做建模。用例场景映射分析业务流程模型，对每个用例（如 “用户下单”），识别参与对象：用例：用户下单 参与者：用户（边界类） 实体：订单（实体类）、商品（实体类）、库存（实体类） 控制：订单创建服务（控制类） 3.2 定义类职责即细化类的静态结构，定义属性和方法。主要遵循以下原则： 原子性：属性应为不可再分的基本数据类型（如订单金额→decimal(10,2)，而非字符串） 单一职责原理：方法应聚焦单一功能（如OrderService.createOrder()仅负责创建订单，不包含支付逻辑） 面向接口：定义抽象接口（如PaymentService），实现类（AlipayServiceImpl、WechatPayServiceImpl）继承接口示例： 注：该阶段的产出为UML图中的类对象，实践中类对象详细的属性和方法是频繁变化的，概要设计阶段仅保证核心描述流程的属性和方法即可。3.3 建立类间关联关系运用面向对象架构模型，构建系统静态结构。3.3.1 分层架构分层架构是比较实用并且通用的模式，对于多数程序是一个良好起点，尤其是当您不确定哪种架构模式最适合您的应用程序时。┌───────────────────────┐│ Presentation Layer │├───────────────────────┤│ Business Logic │├───────────────────────┤│ Data Access Layer │└───────────────────────┘3.3.2 洋葱架构（Clean-Architecture）洋葱架构着重于解决分层架构中上层对下层的强依赖问题，如果业务逻辑（Business Logic）不存在，UI （Presentation Layer）将无法运行。如果没有数据访问（Data Access Layer），业务逻辑（Business Logic）就无法运行。而洋葱架构强调整个系统的关注点分离，使得应用程更易于维护。3.3.3 DDDddd是解决复杂业务系统的架构设计方式，并不适用于所有业务系统，在进行架构设计时需要考虑清楚ddd是否适用于现有业务。如果业务较简单，并不建议使用ddd,因为ddd带来的沟通成本、学习成本、维护成本都会增加。ddd中的概念及设计原则可以进行借鉴，比如边界上下文、领域划分、防腐层、依赖倒置等，可以解决业务间依赖，使业务隔离。3.3.4 Event Sourcing与事件驱动架构事件驱动架构（Event-Driven Architecture，简称EDA）和Event Sourcing是两种非常重要的软件架构设计模式，它们在近年来逐渐成为软件开发中的主流方法。事件驱动架构是一种基于事件的异步通信方式，它使得系统的各个组件可以在不同时间和不同位置之间进行通信，从而提高了系统的灵活性和可扩展性。而Event Sourcing则是一种基于事件的数据存储方法，它将数据存储为一系列事件的序列，从而实现了数据的完整性和可恢复性。事件驱动架构和Event Sourcing是两种相互关联的软件架构设计模式，它们可以相互支持和完善。事件驱动架构可以让系统的各个组件更加灵活和可扩展，而Event Sourcing可以让数据更加完整和可恢复。在实际应用中，事件驱动架构和Event Sourcing可以相互支持，例如，事件驱动架构可以使用Event Sourcing来存储和处理事件，而Event Sourcing可以使用事件驱动架构来处理事件。3.4 应用设计模式利用设计模式，提升类的可维护性与扩展性。设计模式原则： 开闭原则（OCP）将易变逻辑封装为策略类（如促销规则PromotionStrategy接口），新增促销方式时无需修改原有代码。 里氏替换原则（LSP）确保子类可完全替换父类（如VIPUser继承User时，支付方法返回值类型需一致）。 迪米特法则（LoD）减少类间不必要的直接依赖，通过中介者模式（Mediator）解耦（如订单与库存不直接交互，通过OrderMediator协调）。3.4.1 创建型模式（对象创建机制）用于封装对象创建逻辑，解耦对象生成与使用，提升灵活性和复用性| 模式 | 核心思想 | 典型场景举例 || ———- | —————————————————————— | —————————————————————————— || 工厂方法 | 定义一个创建对象的接口，由子类决定实例化具体类（延迟到子类实现）。 | 电商系统中，根据不同支付方式（支付宝、微信支付）创建对应的支付处理器。 || 抽象工厂 | 提供一个创建相关或依赖对象族的接口，无需指定具体类。 | 跨平台 UI 组件库，创建不同操作系统（Windows/Mac）的按钮、窗口等组件族。 || 单例模式 | 确保类只有一个实例，并提供全局访问点。 | 日志管理器、配置管理器（整个应用只需一个实例管理全局状态）。 || 建造者模式 | 将复杂对象的构建过程与表示分离，允许相同构建过程创建不同表示。 | 订单生成：分步组装订单的用户信息、商品列表、配送地址、支付方式等复杂对象。 || 原型模式 | 通过复制现有对象（原型）创建新对象，避免重复初始化逻辑。 | 游戏中复制 NPC 角色：基于基础角色原型（如 “士兵”）快速生成多个属性微调的实例。 |3.4.2 结构型模式（类 / 对象的组合结构）用于优化类或对象的组合方式，形成灵活的结构，解决复杂系统的层次和依赖问题。| 模式 | 核心思想 | 典型场景举例 || ———- | ——————————————————————————- | ————————————————————————————— || 适配器模式 | 转换一个类的接口，使其能与另一个不兼容的接口协同工作（类适配器 / 对象适配器）。 | 旧系统兼容：将第三方支付接口（如 VISA）适配为系统内部统一的支付接口格式。 || 桥接模式 | 将抽象部分与实现部分分离，使两者可独立变化，通过组合而非继承关联。 | 跨平台图形系统：抽象 “图形”（如矩形、圆形）与 “平台实现”（Windows/GDI、Java/AWT）解耦。 || 组合模式 | 将对象组合成树形结构，统一处理单个对象（叶子）和组合对象（容器）。 | 文件系统：文件夹（容器）和文件（叶子）统一视为 “节点”，支持递归遍历、操作。 || 装饰器模式 | 动态给对象添加额外职责，通过包装器（Decorator）扩展功能，避免继承臃肿。 | 电商商品展示：给 “商品” 对象动态添加 “促销标签”“库存提醒”“价格高亮” 等附加功能。 || 外观模式 | 为复杂子系统提供统一接口，简化外部调用（门面模式）。 | 视频播放系统：对外暴露简单的 “播放” 接口，内部封装解码、渲染、音频同步等复杂子系统。 || 享元模式 | 共享多个对象的公共状态，减少内存占用，适用于大量细粒度对象场景。 | 文本渲染：共享 “字符” 对象的字体、颜色等公共属性，不同位置的相同字符复用实例。 || 代理模式 | 为对象提供一个代理或占位符，控制对原对象的访问（远程代理、虚拟代理等）。 | 图片加载：使用代理对象先显示占位图，真实图片加载完成后替换，避免阻塞界面。 |3.4.3 行为型模式（对象交互与职责分配）用于定义对象间的通信机制和算法分配方式，解耦复杂交互逻辑，提升系统灵活性和可维护性。| 模式 | 核心思想 | 典型场景举例 || ———- | ———————————————————————————- | ———————————————————————————————————— || 策略模式 | 定义一系列算法，将每个算法封装为独立策略类，可相互替换（策略族）。 | 电商促销：不同促销策略（满减、折扣、赠品）动态切换，订单计算时按需选择策略。 || 模板方法 | 在抽象类中定义算法骨架，具体步骤由子类实现（钩子方法）。 | 电商订单处理模板：抽象类定义 “创建订单→校验库存→扣款→发货” 骨架，子类实现 “扣款”（支付宝 / 微信）细节。 || 观察者模式 | 定义对象间的依赖关系，当主题（Subject）状态变化时，通知所有观察者（Observer）。 | 消息订阅：用户关注商品后，商品降价时自动通知所有订阅用户（微信 / 短信 / 站内信）。 || 迭代器模式 | 提供统一接口遍历集合对象，隐藏内部数据结构（如数组、链表）。 | 数据展示：表格组件通过迭代器遍历不同类型的数据集（列表、树结构），统一渲染。 || 责任链模式 | 将请求处理者连成链，请求沿链传递，直到有处理者响应（避免请求发送者与处理者耦合）。 | 审批流程：报销单按金额大小依次由组长、部门经理、CEO 审批，形成链式处理。 || 命令模式 | 将 “请求” 封装为对象（命令对象），支持日志、撤销、异步执行等操作。 | 文本编辑器：“撤销” 功能通过记录命令对象（如 “插入文本”“删除文本”）实现回退。 || 备忘录模式 | 捕获对象内部状态并保存（备忘录），以便恢复到历史状态（撤销操作）。 | 游戏存档：保存玩家当前游戏状态（血量、装备、进度），支持读档恢复。 || 状态模式 | 对象的行为随内部状态改变而变化，将状态逻辑封装为独立状态类。 | 电商订单状态：订单根据状态（待支付、已支付、已发货、已取消）切换不同的操作逻辑（如 “已取消” 订单不可支付）。 || 访问者模式 | 封装作用于对象结构中各元素的操作，使操作可独立于元素类变化（数据与操作分离）。 | 电商报表：针对 “商品”“订单”“用户” 等不同元素，访问者（如 “销售额统计”“用户活跃度分析”）可灵活添加新操作。 || 中介者模式 | 用中介对象封装对象间的交互逻辑，避免对象直接引用，降低耦合（星型结构）。 | 即时通讯：用户（User）之间不直接通信，通过中介者（ChatMediator）转发消息，解耦用户关联。 || 解释器模式 | 定义语言的文法（语法规则），并实现解释器来解析该语言中的句子（较少使用）。 | 表达式计算：解析数学表达式（如 “a + b * c”），根据文法规则计算结果（仅复杂场景使用）。 |4 数据库设计（概念结构设计）通过 E-R 图（实体 - 关系图） 抽象业务概念，定义实体、属性及关系，形成独立于数据库管理系统的概念模型，为逻辑设计提供直接输入。 注：数据库设计流程包含概念结构设计和物理结构设计，概要设计阶段输出概念结构指导技术落地即可，物理结构待详细设计阶段补充。4.1 实体获取和定义 识别实体： 从需求文档、用例图、业务流程图中提取名词短语，筛选具有独立业务含义且具有唯一标识的对象作为候选实体（如 “商品”“分类”），排除抽象概念（如“报表”、“缓存”、“日志”） 从UML图提取对象实例，映射为数据库实体 定义关系： 一对一（1:1）：用户与用户详情（1 个用户对应 1 个详情） 一对多（1:M）：分类与商品（1 个分类包含多个商品） 多对多（M:N）：用户与角色（1 个用户可拥有多个角色，1 个角色可分配给多个用户，需中间表） 属性分类： 主键属性：唯一标识实体（如用户 ID） 复合属性：可分解的属性（如 “地址” 分解为省、市、区） 派生属性：通过计算得到（如 “订单总价” 由 “商品单价 × 数量” 派生） 4.2 绘制E-R图示例：erDiagram 用户 ||--o{ 订单 : 创建 订单 ||--o{ 订单详情 : 包含 用户 ||--|{ 用户角色 : 拥有 角色 ||--|{ 用户角色 : 拥有 分类 }|--|| 商品 : 属于三、详细设计详细设计是将概要设计转化为可直接编码实现的技术文档，聚焦模块内部逻辑、算法、接口及数据结构设计。我将围绕业务流程、系统服务、用户界面等模块，细化实现细节和技术方案。对应概要设计产出为:| 设计阶段 | 产出 || —————— | ————— || 业务流程建模 | 异常码清单 || 系统服务设计 | 服务接口清单 || 面向对象设计和建模 | 流程图、类属性-方法清单、设计模式/算法实现 || 数据库设计 | 数据库表清单 |另外根据软件系统的类型，还可能要进行以下设计:1) 代码设计。为了提高数据的输入、分类、存储和检索等操作，节约内存空间，对数据库中某些数据项的值要进行代码设计1) 输入/输出格式设计2) 用户界面设计1 业务流程建模详细设计1.1 补充时序图实现细节包括但不限于： 子流程：如库存锁定失败补偿流程 超时控制：如接口超时时长限制500ms，超时后触发熔断机制 幂等性设计：如在订单确认环节，重复请求直接返回已处理结果1.2 状态图工程化说明实现状态转换的技术，如： 状态机框架：Spring State Machine或其他框架构建状态转换逻辑，定义订单状态枚举类OrderStatus（NEW、PAID、CANCELED ）等​ 事件驱动：每个状态转换对应明确的事件，如PAY_SUCCESS事件触发订单从NEW到PAID状态迁移，并自动调用库存扣减服务 流程驱动：利用流程引擎驱动状态转换1.3 异常码清单依据异常处理矩阵和最终程序实现，补充异常码清单，如：| Error Code | Error Message || ———- | ————- || 10001 | 参数错误 || 10002 | 支付失败 || 10003 | 库存锁定失败 |2 系统服务详细设计2.1 服务间通信补充详细的通信实现方式，如： RPC 调用：使用 gRPC 实现服务间高效通信，定义 Proto 文件规范数据格式。例如，用户服务与订单服务之间的用户信息查询采用 gRPC 调用，提升传输效率。​ 消息队列：通过 RabbitMQ 实现异步解耦，如订单创建成功后，发送消息通知物流服务进行发货处理。2.2 服务接口定义补充系统服务间通信的详细API及安全协议，输出接口清单。 RESTful API 设计：遵循 OpenAPI 规范，使用Swagger等工具生成接口文档。以商品服务为例，定义以下接口：​ GET /products/{productId}：获取商品详情​ POST /products：创建商品​ PUT /products/{productId}：更新商品信息​ 接口安全：如JWT令牌、auth2等认证机制，及接口网关等设计。3 面向对象详细设计3.1 类的实现细节3.1.1 复杂逻辑方法流程图​针对复杂的业务逻辑和方法调用补充设计细节，以User类的注册方法register和为例，绘制流程图：graph TD; A[register] --&gt; B[接收注册信息: username, phoneNumber, email]; B --&gt; C{信息格式是否正确}; C -- 是 --&gt; D[生成唯一userId]; D --&gt; E[使用BCrypt加密password]; E --&gt; F[将用户信息存入数据库]; F --&gt; G[返回注册成功]; C -- 否 --&gt; H[返回错误信息]; H --&gt; I[结束];3.1.2 补充类属性-方法清单清单示例 - User 类： 类属性名称 数据类型 说明 约束条件 userId int 用户唯一标识 ID 唯一索引 username String 用户姓名 非空，长度不超过 50 phoneNumber String 用户手机号码 非空，唯一，符合手机号格式 email String 用户电子邮箱 可空，符合邮箱格式 createTime LocalDateTime 用户创建时间 默认值为当前时间 类方法名称 方法返回值 说明 参数列表 register boolean 用户注册方法，将用户信息保存到系统中。 username, phoneNumber, email（可选） login boolean 用户登录验证方法，根据用户名和密码（假设密码在其他逻辑中处理）验证用户身份。 username, password（假设传入） updateProfile void 更新用户个人信息方法，可更新除 userId 外的其他信息。 newUsername（可选）, newPhoneNumber（可选）, newEmail（可选） 3.2 设计模式和算法实现细节必要时补充，如： 策略模式​ 应用场景：处理不同支付方式（支付宝、微信支付、银联支付），使支付逻辑可动态切&gt; 换 实现细节：定义抽象支付策略接口PaymentStrategy，包含pay方法；具体支付类如&gt; AlipayStrategy、WechatPayStrategy等实现该接口。在订单支付时，根据用户选择的&gt; 支付方式调用对应的策略实现支付```` javainterface PaymentStrategy { boolean pay(BigDecimal amount, String orderId);} class AlipayStrategy implements PaymentStrategy { @Override public boolean pay(BigDecimal amount, String orderId) { // 调用支付宝支付接口逻辑 System.out.println(“使用支付宝支付，订单号：” + orderId + “，金&gt; 额：” + amount); return true; }} class WechatPayStrategy implements PaymentStrategy { @Override public boolean pay(BigDecimal amount, String orderId) { // 调用微信支付接口逻辑 System.out.println(“使用微信支付，订单号：” + orderId + “，金额：&gt; “ + amount); return true; }}```` 用户密码加密与验证算法​ 应用场景：用户注册时加密密码存储，登录时验证密码正确性。 实现细节：使用 BCrypt 算法进行密码加密，在User类的register方法中对用户输入&gt; 的密码调用BCrypt.hashpw方法加密后存储；在login方法中，使用BCrypt.checkpw方&gt; 法对比输入密码与数据库中加密密码是否匹配 import org.mindrot.jbcrypt.BCrypt;​​public class User {​ private String passwordHash;​​ public void register(String password) {​ passwordHash = BCrypt.hashpw(password, BCrypt.gensalt());​ }​​ public boolean login(String password) {​ return BCrypt.checkpw(password, passwordHash);​ }​} 3 数据库设计详细设计（物理结构设计）数据库物理结构设计将E-R图转换为关系模式，选型具体的数据库系统，设计表、索引、存储策略，优化性能与存储效率。实际上，数据库设计的基本过程与任何复杂系统开发一样，在每一阶段设计基本完成后，都要进行认真的检查，看是否满足应用需求，并析设计结果的合理性。在每一步设计中，可能发现前面步骤的遗漏或处理不当之处，此时，往往需要返回去重新处理并修改物理结构。所以，物理结构设计过程通常是一个反复修改、反设计的迭代过程。4.1 操作要点 DBMS 选型 关系型数据库（OLTP）：MySQL（常用）、PostgreSQL（高并发）、Oracle（强事务） 非关系型数据库（OLAP）：MongoDB（文档存储）、Cassandra（分布式海量数据） 表结构优化 字段顺序：常用字段前置（如user_id、create_time放前，提升查询效率）。 自增主键：使用AUTO_INCREMENT（MySQL）或SEQUENCE（Oracle），避免业务字段作为主键（如用户手机号可能变更）。 分区设计： 按时间分区：order表按年份分表（order_2023、order_2024），降低单表数据量。 按范围分区：用户表按user_id范围分布（1-100 万、100 万 - 200 万），均衡负载。 索引设计 必加索引：主键（自动创建）、外键、唯一约束字段（如user.mobile）。 组合索引：遵循 “最左匹配” 原则（如(user_id, create_time)支持user_id单查或两者联合查询）。 避免过度索引：写入频繁的表（如日志表）减少索引，避免插入 / 更新性能下降。 存储引擎选择 MySQL： InnoDB：支持事务、外键，适合 OLTP（订单、用户表）。 MyISAM：不支持事务，适合只读报表表。 PostgreSQL：使用默认Heap存储，或针对高频查询用BRIN索引（范围查询优化）。 4.2 示例 - 数据库表清单表清单| 表名 | 说明 | 依赖/引用 || ———- | ———- | ———————————– || user | 用户表 | || order | 订单表 | 依赖 user 表，引用其 user_id 字段 || order_item | 订单详情表 | 依赖 order 表，引用其 order_id 字段 || product | 商品表 | |表说明订单详情表 索引设计：order_id和product_id字段上创建联合索引，提升用户订单查询效率​ 分表：按id范围进行分区，减少单表数据量，提高查询性能 字段名 数据类型 字段说明 order_item_id int 订单详情 ID，主键 order_id int 订单 ID，外键，关联 order 表的 order_id 字段 product_id int 订单 ID，外键，关联 order 表的 order_id 字段 quantity int 商品数量 " }, { "title": "分布式事务解决方案", "url": "/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/", "categories": "企业架构设计", "tags": "架构设计", "date": "2024-04-29 13:34:04 +0800", "snippet": " [注意] 所有的分布式事务方案，均无法100%保证成功（包括提交和回滚），应综合考虑人工介入处理的时效性和难度，对于现金交易等高敏感性业务不应采用分布式事务方案。条件允许的情况下，应该尽可能地使用单机事务，永远记住：Simple is the best！现有解决方案对比目前主流分布式事务方案都基于2PC、3PC、TCC、SAGA几种模型衍生，形态上有以下几种类型：1. 数据库原生以XA协...", "content": " [注意] 所有的分布式事务方案，均无法100%保证成功（包括提交和回滚），应综合考虑人工介入处理的时效性和难度，对于现金交易等高敏感性业务不应采用分布式事务方案。条件允许的情况下，应该尽可能地使用单机事务，永远记住：Simple is the best！现有解决方案对比目前主流分布式事务方案都基于2PC、3PC、TCC、SAGA几种模型衍生，形态上有以下几种类型：1. 数据库原生以XA协议为代表的数据库原生方案，是实现了ACID特性的刚性事务。优点： 业务的侵入性低缺点： 全局加锁，并发性能差2. 消息驱动方案最大努力送达，适合用于“对数据库的操作最终一定能够成功”的场景。基于死信队列的最终一致性事务，适用于实时性要求较低的场景。优点： 逻辑简单 性能损耗小缺点： 适合的业务场景较少 脏读问题 与消息中间件耦合度高3. 基于分布式锁方案主要是基于TCC模式的开源框架优点： 适合的业务场景较多 性能损耗较小 兼容必须使用XA的场景缺点： 需要业务代码实现Try、Confirm、Cancel三个接口，代码入侵性强。 有空回滚、幂等、悬挂问题 开发成本大4. 中间件主要有Seata等分布式中间件，和Mycat等数据库代理中间件。优点： 不同中间件不同 业务侵入性相对较小缺点： 不同中间件不同 维护成本较高 有一定性能损耗KTech New Platform 方案选型经过技术调研，结合银行业务场景，KTech New Platform最终选择集成Seata作为分布式事务解决方案，有以下几点原因：1. 支持多种分布式事务协议在实际生产环境中，不同的业务场景适合采用的分布式事务策略均有不同，Seata封装XA、TCC、SAGA模式及自研的AT模式，基本覆盖实际业务场景。采用Seata可有效降低自研复杂度和业务人员使用难度。2. 开源且代码质量优秀阅读Seata源码可知，Seata底层采用Netty实现tm、rm、tc间通信，从而实现全局事务开启、分支事务注册、提交、回滚和消息监听等功能，逻辑清晰结构简单；通过各种Handler、Listener、AOP实现了简便的API，开发使用难度低。3. 性能满足基本需求依据官方说明，Seata集群吞吐量可达10万次/秒。以目前行内架构数据库理论性能峰值（预估在3000QPS-6000QPS范围内）计算，Seata不会成为压力瓶颈，链路的TR增长也在可接受范围内。 4. 分布式中间件方案较合理对比其他方案，分布式中间件在性能、可靠性、灵活性、使用难度等方面达到较好的平衡。5. 中文社区活跃Seata中文社区活跃度高，更适应国内开发风格和场景，后续升级迭代都有具备较好保障。[1]分布式事务之解决方案（TCC）[2]如何选择分布式事务形态（TCC，SAGA，2PC，补偿，基于消息最终一致性等等）[3]深度解析MySQL分布式事务原理[4]Seata：连接数据与应用" }, { "title": "网络通信的可靠性保证方法", "url": "/posts/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E8%AF%81%E6%96%B9%E6%B3%95/", "categories": "企业架构设计", "tags": "架构设计", "date": "2024-04-29 13:34:03 +0800", "snippet": "重试机制使用消息队列可以实现接口请求的异步重试机制。基本思路是: 接口请求发送失败后,将请求信息封装为消息,发送到请求重试的队列中。 消息消费者从队列中获取失败的请求,根据策略进行重试。 重复重试直到成功、重试次数用尽或其他终止条件。 成功后将消息移除队列,失败则保留消息供再次重试。主要步骤: 创建请求重试队列,如“request.retry.queue” 接口请求失败后,生成重...", "content": "重试机制使用消息队列可以实现接口请求的异步重试机制。基本思路是: 接口请求发送失败后,将请求信息封装为消息,发送到请求重试的队列中。 消息消费者从队列中获取失败的请求,根据策略进行重试。 重复重试直到成功、重试次数用尽或其他终止条件。 成功后将消息移除队列,失败则保留消息供再次重试。主要步骤: 创建请求重试队列,如“request.retry.queue” 接口请求失败后,生成重试消息,发送到队列 消费者启动线程从队列中取消息重试 根据重试策略进行定时重试或最大重试数 成功则确认消息,失败则重新入队使用消息队列进行重试有利于: 异步重试,不阻塞主线程 可靠地完成重试任务 灵活控制重试策略数据加密B2C公网环境使用HTTPS已经能很好地保证数据安全，业务功能依据具体需求进行敏感数据加密或脱敏即可。B2B服务开放OpenAPI时，涉及多端授权，需要通过密钥或证书对消息内容进行加签、验签，从而保证双方通信消息的安全性和真实性。基本思路是 系统为下游服务创建clientId、clientSecret，密钥在两端都保存。 向外部服务发送请求时，平台对消息体进行加签/加密，外部服务对消息验签/解密。 同样，平台接收外部服务请求时，外部服务对加签/加密，平台对消息体进行验签/解密。非对称加密+对称加密在安全系数要求较高的接口中，通常会采用RSA等非对称加密手段，但在加密数据体较大时RSA加密会导致包体膨胀和性能下降的问题，此时可采用非对称加密+对称加密方式。幂等校验对于需要进行数据修改的功能，接口必须进行幂等性校验。防重表数据库防重利用数据表唯一索引的特性，当并发时新增报错时，再查询一次，数据已经存在，就避免了脏数据的新增。但注意，不要将 uuid 作为索引字段，其大小和类型对于索引而言都会导致速度非常慢。常见的场景，比如博客 / 微博系统点赞，一个用户对一个微博点赞，就把用户 id 与该博文 id 绑定，后续该用户再对该博文点赞就无法插入。再比如金融账户，可以通过在账户表中增加唯一索引来存储用户 id，即使重复操作一个用户也只能拥有一个账户。分布式锁防重表可以使用分布式锁代替，比如Redis。订单发起支付请求，支付系统会去Redis缓存中查询是否存在该订单号的Key，如果不存在，则向Redis增加Key为订单号。查询订单支付已经支付，如果没有则进行支付，支付完成后删除该订单号的Key。通过Redis做到了分布式锁，只有这次订单订单支付请求完成，下次请求才能进来。相比去重表，将放并发做到了缓存中，较为高效。状态标识利用业务本身状态判断。常见的场景如三方支付系统在用户支付完成后向应用系统发送付款回调，业务系统更新订单状态标识为已付款，后续重复收到付款回调则忽略请求。token 令牌机制token 机制是使用范围最广泛的一种幂等设计。虽然实现方式有很多种，但核心思想就是每次操作都生成一个唯一 token 凭证，服务器通过这个唯一凭证确保同样的操作不会被执行多次。这个方案适合简单业务场景，如接口防抖，不适合用于安全性一致性要求较高的场景。" }, { "title": "KTech New Platfrom 架构原则", "url": "/posts/KTECH-New-Platfrom-%E6%9E%B6%E6%9E%84%E5%8E%9F%E5%88%99/", "categories": "企业架构设计", "tags": "架构设计", "date": "2024-04-29 13:34:02 +0800", "snippet": "基于![技术架构选型]中对各个架构模式的理解，并结合银行产品特性以及对云原生架构的适应性，本文说明KTECH New Platfrom的架构原则。架构模式KTECH New Platfrom选择以Mini-Service架构为基础的微服务模式，遵循以下原则： 项目工程模块以微服务方式设计，并组合为单个web项目部署，从而确保在拆分服务时更便捷。 允许多个业务模块共享同一个数据库，同时仅在...", "content": "基于![技术架构选型]中对各个架构模式的理解，并结合银行产品特性以及对云原生架构的适应性，本文说明KTECH New Platfrom的架构原则。架构模式KTECH New Platfrom选择以Mini-Service架构为基础的微服务模式，遵循以下原则： 项目工程模块以微服务方式设计，并组合为单个web项目部署，从而确保在拆分服务时更便捷。 允许多个业务模块共享同一个数据库，同时仅在数据库层完全解耦时允许微服务拆分。 通用服务与业务服务间通过REST API或异步方式通信。 除微服务网关，不同微服务必须采用基于事件的异步方式通信。 微服务间应各自保证可用性。架构原则说明：原则1考虑到目前银行项目的性能要求和硬件资源成本，采用New Platfrom的项目应从单体模式开始发展架构，同时应保持拆分微服务的能力，参考以下New Platfrom项目结构：Halo-Cloud ├── halo-gateway // 网关模块 [8080]├── halo-admin // 管理端 [9200]├── halo-api // 接口模块│ └── halo-api-resource // 资源api模块│ └── halo-api-system // 系统接口├── halo-common // 通用模块│ └── halo-common-core // 核心功能模块│ └── ruoyi-common-dict // 字典集成模块│ └── halo-common-datasource // 多数据源│ └── halo-common-log // 日志记录│ └── halo-common-redis // 缓存服务│ └── halo-common-seata // 分布式事务│ └── halo-common-security // 安全模块├── halo-modules // 业务功能│ └── halo-system // 系统模块 [9201]│ └── halo-job // 定时任务 [9202]│ └── halo-file // 文件服务 [9300]│ └── halo-auth // 认证中心 [9200]├──pom.xml // 公共依赖halo-admin本身不包含业务功能，而是作为web容器集成各个模块；halo-modules是按照微服务领域拆分的业务模块，通常被集成到halo-admin中部署为单个web项目，也可以拆分为以微服务单独部署。halo-common是通用模块，以jar包形式集成到各个业务模块中使用。这么一来从部署模式上是单体架构，构建小型项目时可以节省硬件资源，必要时也可以微服务模式拆分部署，从而适应更高的性能和负载需求。原则2鉴于前文中提到的银行系统的高数据一致性需求，通常难以基于业务拆分数据库，强行拆分还可能导致更高的分布式事务成本。因此平台以Mini-Service模式为指导思想，允许不同业务领域共享数据库，但此时不应拆分微服务。服务若存在相互抢占资源现象，仍然保持集群部署，并通过负载均衡策略将不同服务请求分别代理到不同服务组。反过来说，如果业务数据库可完全解耦，则可以考虑进行微服务拆分，形成更清晰的项目结构。原则3短信服务中心、工作流中心、文件中心等服务，属于通用基础功能，本身不包含业务逻辑，可以拆分微服务。并且，由于业务服务对基础功能基本上是强依赖的（无论工作流引擎是集成到业务服务还是单独部署，引擎不可用均会导致业务功能异常，不适用服务降级）因此保证通信可靠即可，而基于Http的通信在内网中完全可靠，因此允许通用服务与业务服务间通过REST API方式通信。原则4不同微服务必须采用基于事件的异步方式通信，反之则不应拆分微服务。例如在信贷业务中，SCF服务与Lending服务共同完成授信业务，此时相较于REST API，事件驱动的通信模式可保证服务不会因为某个业务环节异常而丢失，因此完全适合拆分为两个服务，分别关注SCF产品功能和贷款审批功能。原则5在SpringCloud体系中，微服务应注册到同一个注册中心，从而监控整个集群健康度。基于前几条原则，在KTech Platform的设计中不存在超大型的微服务集群和超长的业务链路，此时每个服务各自保证可用性在管理时更为清晰。就像，在项目中集成Apollo配置中心时，完全可以让Apollo单独部署到自己的Eureka中，业务服务不需关注Apollo的可用性。这样做的另一个好处是，服务不一定需要Eureka等注册中心组件，通过Nginx+集群的模式也能保证服务高可用（此时牺牲的是网关动态发现服务的能力），此时在K8s体系下可以以云原生方式部署从而更好地利用云原生架构优势。更利于项目后期在SpringCloud体系和K8s体系下演进。技术框架选型为了兼容Mini-Service(SpringBoot)/MicroService(SpringCloud)/云原生(K8s)架构，同时保持项目架构简洁清晰，KTech New Platfrom选择以下微服务组件：注册中心采用Nacos做注册中心 注册中心组件本身代码侵入性低，无论是k8s切换到spring cloud，还是spring cloud到k8s，迁移难度都不高。服务间通信/负载均衡采用经裁剪的Feign+Ribbon 相较原生Rest API，经过RPC包装后的协议使用更方便，也利于框架统一处理通信层逻辑。 依照Ktech Platform架构设计原则，采用url配置FeignClient，从而更好地兼容云原生场景。```javaimport org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;@FeignClient(url = “http://remote-service:8080”)public interface RemoteServiceClient { @GetMapping(“/hello”) String sayHello();}```熔断/限流/降级小规模项目不采用 &gt; Istio+Sentinel &gt; Sentinel 由于该组件代码侵入性非常高，架构迁移的成本也会更高。目前没有较兼容的解决方案，最好在项目架设初期就确定采用的方案。链路监控采用Zipkin Zipkin在SpringCloud和K8s体系均有较好表现消息总线采用RabbitMQ RabbitMQ相较RocketMQ在AWS等海外云中支持性更好 RabbitMQ适合银行系统等可靠性要求较高的场景服务拆分指引基于组织结构拆分康威定律: 一个组织的系统通常被设计成这个组织通信结构的副本。 定律一: 组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。 定律二: 时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。 定律三: 线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。 定律四: 大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。基于领域（业务模块）拆分微服务只是手段，不是目的。从业务出发，通过领域模型的方式反映系统的抽象，围绕业务领域按职责单一性、功能完整性拆分。考虑以下几个阶段： 进行业务建模，从业务中获取抽象的模型（例如订单、用户），根据模型的关系进行划分限界上下文。 检验模型是否得到合适的的抽象，并能反映系统设计和响应业务变化。 从限界上下文往微服务转化，并得到系统架构、API列表、集成方式等产出。" }, { "title": "云原生架构介绍及技术选型", "url": "/posts/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%BA%91%E5%8C%96%E6%94%B9%E9%80%A0%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/", "categories": "企业架构设计", "tags": "架构设计", "date": "2024-04-29 13:34:01 +0800", "snippet": "什么是云原生理解云原生前首先要明白什么是“云”，“云”即“云技术”，指用户可以在任何时间、任何地点通过网络访问存储在远程服务器中的数据或使用计算服务，它有三种主要形式：基础设施服务IAAS，指虚拟机、存储、网络、操作系统等基础设施层面服务；平台服务PAAS，指将IAAS包装成平台，提供一系列开发、管理、监控功能的服务；应用服务SAAS，指在PAAS基础上构建好的应用程序，通常以订阅方式提供，...", "content": "什么是云原生理解云原生前首先要明白什么是“云”，“云”即“云技术”，指用户可以在任何时间、任何地点通过网络访问存储在远程服务器中的数据或使用计算服务，它有三种主要形式：基础设施服务IAAS，指虚拟机、存储、网络、操作系统等基础设施层面服务；平台服务PAAS，指将IAAS包装成平台，提供一系列开发、管理、监控功能的服务；应用服务SAAS，指在PAAS基础上构建好的应用程序，通常以订阅方式提供，用户不必关注程序的维护、升级和扩展。从技术架构角度而言，软件开发依赖IAAS、PAAS设施，构建SAAS服务，此时“云”默指各种公有云、私有云设施。因此，“云原生（应用）”从字面拆解，可理解为在云（平台）中依托平台“原生”能力体系构建的一系列应用。CNCF官方对云原生的定义是：Cloud native technologies empower organizations to build and run scalable applications in modern, dynamic environments。所以，“云原生”是一个统称词，是一系列技术的统称。针对系统设计、研发、部署和运营的各种挑战，“云原生”提出了几个关键的着力点： 微服务：解决系统设计的粒度问题，提供服务间发现、交互、调用等能力。 DevOps：解决自动化和质量控制问题。 容器：解决兼容性和细粒度调度问题。 可观测性：解决对系统状态的感知问题。目前主流云原生架构均基于K8S体系，因此也可以简单理解云原生技术为K8S体系技术。K8S体系应用架构一图流：云原生技术选型选型主要对比SpringCloud体系和K8S体系技术差异，依据银行产品性能、运维、技术需求，挑选两个体系架构间低成本切换的技术组件。SpringCloud-K8SSpringCloud提供了K8S-Starter组件包，可以配置化地将SpringCloud体系应用注册到K8S中，相当于保留SpringCloud-Config，移除Nacos，为Feign添加代理的版本。这种方式适合用于SpringCloud应用上云，其整体为系统整体增加了复杂度，需要管理更多的配置及中间件，并不推荐用于原生项目架构选型。应酌情采用。服务发现K8S依靠通过Endpoints管理Pod对象地址，Demployment可调度微服务集群，并通过将Demployment注册到Service中，即可在K8S体系中实现非侵入的服务发现功能，无需依赖Nacos等微服务组件。由于SpringCloud体系中注册服务发现中心并不需要编写代码，因此只要移除Nacos相关依赖及配置文件，即可迁移至K8S平台。故优先级：k8s servcie = nacos应用网关/负载均衡K8S网关存在Ingress、Nginx-Ingress、Ingress-Contoller等不同实现，其中Ingress-Contoller是完全迭代重构后的产物，优先推荐。对比Nginx，SpringCloud-Gateway最主要的区别在于，当下层服务增加/减少时，Gateway可自行感知并分流，这是通过服务发现机制实现的能力。由于K8S本身已经具备服务发现能力，K8S应用网关（Ingress）只需关注下层Service，具体的服务感知和负载均衡均由Service提供，因此网关只需具备基本的路由功能，也因此存在Nginx-Ingress等方案。另一方面，通过自定义Filter，SpringCloud-Gateway可以提供加密、XSS过滤、token验权等业务功能，但在业务生产中证明在Gateway中实现业务功能并非最佳实践，这会极大的降低Gateway性能（并且Gateway性能远不如Nginx），因此在架构设计时也理应将业务功能从Gateway层移出。由于SpringCloud中Gateway的必要性，考虑到SpringCloud迁移至K8S环境的可能，建议尽量降低SpringCloud-Gateway责任，XSS等Filter功能可在各个微服务节点内实现。故优先级：k8s Ingress &gt;= nginx &gt; SpringCloud-Gateway服务通信K8S基于Http2.0通信，底层依靠CoreDNS实现流量转发功能，健壮性由内网网络保障（实践证明可靠性极高），因此官方并不推荐各类RPC框架。国外社区较为流行gRPC方案，由于非中心化设计，本身并不具费容错限流能力，除去具有统一封装API和数据包大小的优点，与原生Http方案并无不同，并且存在学习成本。为了更方便地在SpringCloud 体系间切换，建议采用Feign+Http方案，在K8S中修改注解为指定Service名称url通信。import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;@FeignClient(url = \"http://remote-service:8080\")public interface RemoteServiceClient { @GetMapping(\"/hello\") String sayHello();}优先级：Feign+Http &gt; gRPC = Http容错限流K8S体系主要采用ServiceMash实现容错限流，具体有Istio等方案，由于其本身依赖SideCar服务，存在一定的性能损耗，基本上每个pod占用内存增加3Gb，CPU占用增加50%-80%，每秒RT增加0.8，这对许多对性能敏感的互联网产品而言难以接受，2B产品中则应综合考虑性能损耗和降低的运维成本。在SpringCloud中，Hystrix等方案已停止更新，Sentinel是目前的技术主流，但无论哪种都需要大量代码配置，侵入性较强，迁移和裁剪成本也比较高，最好在项目初期就确定采用的技术框架。对于结构简单、分层清晰的微服务，也可借助消息中心、服务监控等能力降低对限流组件的依赖。结合K8S与SpringCloud两者优点，则可以在ServiceMash中实现限流，在Sentinel中实现降级，从而降低代码耦合度，提高运维配置灵活性。优先级：小规模项目不采用 &gt; Istio+Sentinel &gt; Sentinel" }, { "title": "常见技术架构分析（施工中）", "url": "/posts/%E5%B8%B8%E8%A7%81%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/", "categories": "企业架构设计", "tags": "架构设计", "date": "2024-04-29 13:34:00 +0800", "snippet": "常见的技术架构模型有以下几种 单体/集群模式（Macro） 微服务（Microservice） 云原生（K8S） 其他针对交付型项目和2B场景，本文对以上几种模式分别说明使用的场景和选择方式。单体/集群模式架构（Macro）单体模式将业务服务放在同一个工程中，部署为单个应用，并共享相同的数据库。这是最常见的架构类型，优点就是简单直观。这里只针对他的缺点展开。 服务之间相互抢占资源，...", "content": "常见的技术架构模型有以下几种 单体/集群模式（Macro） 微服务（Microservice） 云原生（K8S） 其他针对交付型项目和2B场景，本文对以上几种模式分别说明使用的场景和选择方式。单体/集群模式架构（Macro）单体模式将业务服务放在同一个工程中，部署为单个应用，并共享相同的数据库。这是最常见的架构类型，优点就是简单直观。这里只针对他的缺点展开。 服务之间相互抢占资源，单个服务的高负载，会拖垮其他服务。 数据库是整个架构的性能瓶颈，Mysql单机QPS仅2500左右。 代码逻辑耦合度高，往往一个模块的修改需要大量关联改造。 扩容需要从服务器搭建从头进行，并需要修改大量配置。我们知道，依据主要消耗资源的类型，服务可以拆分为CPU密集型和IO密集型两个大类，而性能也是基于这两项优化的。CPU密集型指应用主要进行大量CPU运算，在银行业中典型场景有现金结算、风控规则运算、数据分析等。IO密集型是系统运行时大部分时间CPU等待IO操作，这里的IO可以是磁盘、内存、网络通信、服务调用等等。单体模式架构通过集群化部署、代码优化等手段，理论上可以获得无限CPU资源，采用分布式缓存、OSS等手段，可以提高资源的IO上限。但由于数据库本身特性，常见的Mysql数据库通常单机QPS也就2000-3000左右，其他组件都能高出几个量级，因此通常性能瓶颈都出现在数据库上。 单体模式架构适合团队规模在5-10人，小型、简单、功能单一的项目，如官网、各种技术中间服务。微服务架构（Microservice）微服务架构的核心，是将大服务拆成小服务，并要求这些服务彼此完全独立。服务本身独立开发、部署和管理，无需了解周围的服务；服务间分离数据库，从而降低数据层性能压力；服务之间（原则上）采用异步方式通信，保持低耦合。伴随着微服务架构的普及，SpringCloud等框架成为了当前技术主流，它不但提供了主要的微服务组件，还进一步地拔高了项目整体的技术力： 注册中心：Eureka/Nacos，提供动态管理微服务集群能力 服务通信：Feign，提供基于http的RPC通信能力 负载均衡：Ribbon，提供一系列完善的调度、重试机制 熔断降级: Hystrix，与Feign协作处理服务异常场景 链路监控：Sleuth/Zipkin，微服务运维工具相比单体架构模式，微服务模式对服务和数据库同时进行拆分，避免了逻辑耦合和数据杂糅，同时理论上还获得了无限扩展的可能性，这对于互联网等高并发、高弹性伸缩需求的场景尤为重要。虽然微服务架构提供了各种强大功能，但在实际生产中也暴露了各种弊端。首先，微服务框架引入了更多的组件，产生了更高的复杂度，诸如降级策略、负载均衡策略在交付项目中很难对生产环境精细配置，导致客户产品体验不佳。其次，微服务架构有可能导致资源浪费，即使只有一个服务，架构也至少需要部署注册中心、网关、主服务三个组件，也可能出现为一个小服务就配置了一整台服务器的情况。同时，中间件配置和管理属于技术层面问题，但物理环境又属于基础设施层面问题，这对项目的开发、运维团队协作是巨大挑战。软件工程中没有银弹，微服务拆分一直是生产实践中难题，像DDD等设计思想也因难以落地未能推广开来，微服务拆分问题需要更加深入的思考。总结过往经验发现，业务逻辑的拆分与功能服务拆分不能完全划等号，但通常的设计流程从功能入手拆分服务，结果导致模块间交互关系非常矛盾。以银行业务举例，领域划分为：- 前台，主要分为零售业务、对公业务、资本市场业务、交易结算业务- 中台，也就是风控平台，负责把控和审核授信风险、市场风险、流动性风险- 后台，负责具体的资金管理，即：支付结算、会计记账其中以供应链产品为例，系统则大体拆分为以下几个模块：- 供应链系统，负责具体的产品管理、客户准入、押品管理等功能，并作为授信、贷款、还款等业务的入口- 信贷系统，作为信贷业务的中台，主要提供授信审批、贷后管理、额度管理等功能，支撑供应链系统业务- 风控系统，负责主要的风险评估和审核- 核心系统，负责资金交易- 客户- 额度- 流程- 规则- 综上，针对微服务架构选型，有以下几点建议： 不盲目采用微服务架构，综合考量系统压力、团队成员构成、硬件成本。 对业务逻辑、技术痛点有较深理解和沉淀的团队和项目，能有效利用微服务架构优势的，适合采用微服务架构。 业务模式复杂，业务规模较大，以部门单位进行业务划分的团队，适合采用微服务架构。服务拆分原则（仅作参考）： 从数据库层考虑，对于无法进行分库分表或分布式事务成本过高的模块，不进行服务拆分。 从模块通信方式考虑，完全以同步方式通信的模块，不进行微服务拆分。 领域边界清晰的模块，可以进行拆分。 复用程度高、功能单一，企业内多个项目共用的模块，应优先进行服务拆分。 总体而言，相较单体模式，微服务模式更加先进。在是团队规模超过50人的大型项目首选的架构模式。Spring Cloud体系是目前主流的技术体系，适合也容易吸引优秀的人员加入。另一方面，微服务引入了便捷度的同时也引入了复杂度，因此技术组件选型和服务拆分需要仔细斟酌，以免出现成本上升效率下降等负优化现象。云原生（Cloud Native） CNCF对云原生的定义：Cloud native technologies empower organizations to build and run scalable applications in modern, dynamic environments.云原生，是为了在现代动态环境中，构建 &amp; 运行可弹性拓展应用的，技术手段的集合。云原生技术 = 容器+微服务+智能编排+服务网格…….正如Spring之于Java，K8S是云原生OS的事实标准，K8S对微服务框架组件进行了与Spring Cloud截然不同的诠释。在Spring Cloud中，各个微服务组件按需集成，独立部署，属于应用层方案；K8S则将服务治理组件沉淀到传输层，是非侵入式的微服务方案。在K8S中开发团队提供服务镜像、路由配置，运维团队按需管理负载均衡策略、发布策略，很大程度上解决了上文提到的开发、运维团队协作问题。同时针对灰度发布、版本回退等弹性伸缩编排场景问题，K8S具备比Spring Cloud更完善的解决方案。目前主流的Service Mesh方案都离不开SideCar，Istio相较于SpringCloud，基本上每个pod占用内存增加3Gb，CPU占用增加50%-80%，每秒RT增加0.8，这对大多互联网应用而言都难以容忍。而随着业务需求的不断变化，SideCar容器也会随之变得越来越复杂，甚至到了资源占用消耗超过业务容器，喧宾夺主的地步。云原生架构的复杂度体现在Infra和Dev/Ops上，虽然K8S标准功能足以应付大部分系统需求，但需要对硬件资源进行合理分配，而涉及持久化等硬件调度等特殊场景时，则可能要对K8S组件进行改造，这对小型乃至中型企业和项目来说都是巨大压力。因此若系统采用了云原生架构而甲方企业却不具备K8S运维能力，对应用提供商而言是无疑灾难性的，这应该纳入项目框架选型的一个考虑要素。从上图可以看出，SpringCloud体系与K8S体系组件存在较大差别，现有SpringCloud系统上云有较大的改造门槛。新项目进行技术组件选型时，可针对两者的差异点进行组件和技术架构选择，从而降低迁移复杂度。这点在后续的文章中再详细展开。因此针对云原生架构选型有以下几点建议： 云原生体系不局限于微服务项目，单体和集群一样适用。 性能要求较高的场景不适合采用云原生方案。 项目团队成员流动性较大，技术能力较弱，难以对微服务中间件进行精细管理时，优先考虑采用云原生。 生产环境负载压力变化较大，需要较强的扩容缩容机制时，优先考虑云原生体系。 需要较完善的灰度发布、版本回退等机制时，优先考虑云原生体系。 从Infra层面考虑企业整体的硬件资源分配管理时，考虑云原生体系。 以软件架构发展趋势而言，以K8S为代表的云原生架构是绝对的行业未来趋势，但就目前而言仍存在许多迫切需要解决的缺陷。团队应结合商业模式、产品形态、技术架构，综合考量选择适合当前乃至3-5年适用的架构模式。其他架构模式Mini-ServiceMini-Service介于单体模式和微服务模式之间，它有以下特点： 多个应用程序共享同一个数据库。 服务通过 REST API 相互通信，并且不采用基于事件的异步通信体系结构。 共享基础设施进行部署。观察前文中的SpringCloud组件会发现，它们核心都在解决同步通信问题，但面向服务的架构（SOA）[注]：https://dzone.com/articles/micro-service-mini-service-and-macro-service" }, { "title": "Java字节码增强技术实践（施工中）", "url": "/posts/Java%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5/", "categories": "程序设计", "tags": "Classloader, javassist, Spring, Tomcat", "date": "2022-05-06 13:53:00 +0800", "snippet": "前言定制Classloader和字节码增强在我们日常开发中不多见，这次我有幸在工作中遇到了。所以很多人觉得改Classloader很难，起初我也这么想。但难的不会，会的不难。虽然中间一步一个坑，但踩完坑反而感觉实现的代码过于简单，不值得吹嘘。我尽量把遇到的问题的思考研究过程记录下来，而不是总结式的亮出所有知识点。如果有幸让你读到，也希望你能珍惜来之不易的业务场景，带着批判性思维，跟着问题思考...", "content": "前言定制Classloader和字节码增强在我们日常开发中不多见，这次我有幸在工作中遇到了。所以很多人觉得改Classloader很难，起初我也这么想。但难的不会，会的不难。虽然中间一步一个坑，但踩完坑反而感觉实现的代码过于简单，不值得吹嘘。我尽量把遇到的问题的思考研究过程记录下来，而不是总结式的亮出所有知识点。如果有幸让你读到，也希望你能珍惜来之不易的业务场景，带着批判性思维，跟着问题思考方案，或是读到我的设计时尝试找出其中的缺陷。背景思考这么一个问题，A部门设计完成一套登陆系统后，因为业务需要B部门在此基础上进行二次开发，替换原有功能，但不可以直接修改源码，只能引包并覆盖。例如原有一个账号密码注册功能，但密码编码算法使用了MD5，现在要替换为AES，那么可能会需要替换LoginService中的一个passwordEncode有方法（这只是一个例子，实际的业务场景要复杂得多）。下面用一个demo展示这些关系。demo首先，A部门有创建了tandard项目，实现了用户登录注册的功能：1-1 project standard在”LoginService”中，registry方法实现了注册逻辑，并使用MD5对密码进行编码:@Servicepublic class LoginServiceImpl implements LoginService{ public String registry(String userName, String password) { password = encode(password); System.out.println(\"save user:\" + userName + \" password:\" + password); return \"Success\"; } public String encode(String password) { System.out.println(\"MD5 encoding..\"); try { byte[] hash = MessageDigest.getInstance(\"MD5\").digest(password.getBytes()); return Base64.getEncoder().encodeToString(hash); } catch (NoSuchAlgorithmException ignore) { } return password; }}在LoginController中注入Service进行调用:@RestControllerpublic class LoginController { @Autowired LoginService service; @RequestMapping(\"registry\") public String registry(){ return service.registry(\"zeta\", \"123456\"); }}B部门创建了extended项目，在pom文件中引用standard包，从而继承standard现有的能力。1-2 project extended在extended项目中可以自由进行新功能开发，但重要的是也需要对standard的已有功能进行增强，代码类似是这种形式：@Servicepublic class ExtendLoginServiceImpl extends LoginServiceImpl { @Override public String encode(String password) { System.out.println(\"RSA encode..\"); try { byte[] hash = MessageDigest.getInstance(\"SHA-256\").digest(password.getBytes(StandardCharsets.UTF_8)); return Base64.getEncoder().encodeToString(hash); } catch (NoSuchAlgorithmException ignore) { } return password; }}B部门期望的是，用户调用的依然是/registry接口，其他的逻辑也不变，但encode的实现需要替换成RSA。然而我们知道，由于LoginController使用LoginService注入，直接这么写启动会报错。1-5 project web error 如果是你，会怎么实现这个功能？Spring中的方案目前已有方案扩展Spring中的JavaBean，Srping提供了@Conditional注解，它允许我们对JavaBean的加载进行控制。我们可以这么做，创建一个自定义Condition，在加载标准Bean时，判断扩展Bean是否存在，若存在则不加载。public class ExtenderCondition implements ConfigurationCondition { public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) { String className = ((ClassMetadata) annotatedTypeMetadata).getClassName(); String simpleName = className.substring(className.lastIndexOf('.') + 1); String extendedBean = \"extend\" + simpleName; if (conditionContext.getRegistry().containsBeanDefinition(extendedBean)) { return false; } return true; } public ConfigurationPhase getConfigurationPhase() { return ConfigurationPhase.REGISTER_BEAN; }}然后，在标准类上添加@Conditional注解@Service@Conditional(ExtenderCondition.class)public class LoginServiceImpl implements LoginService{ ...}扩展类只需要按照相应的规则对类名命名，继承标准类并且正常的重写方法，就能实现扩展了。启动并调用接口，能看到此时已经是扩展后的逻辑：问题虽然JavaBean的问题解决了，但原生的Java代码依然无法替换，例如在数据库添加字段时，就需要对应的修改Model，而Model是通过new创建的；又或者是一些工具类，实现的是静态方法；甚至有些工程完全没有使用Spring。领导此时要求我尝试提供一个解决方案。提炼需求首先，接到问题时先把需求和痛点提炼出来： 要设计一个框架，实现代码在二次开发时的替换能力。 要实现原生代码的替换，包括通过new创建的实例。 替换的包括类的属性、方法，也有可能涉及到枚举类。 不能在扩展时修改源码（也就是说要通过运行时动态替换的手段进行逻辑扩展）。梳理现状 项目发布环境时是打成war包，部署到tomcat容器中。 可以让A部门做少量的代码改造，类似Spring的方案只需要写脚本批量给Service添加注解就行。人力和时间上都没有条件做大量的代码重构。 方案要保证不会影响B部门现有代码的正常运行。方案可以在B部门编写新代码时落实。 现在你可以开始思考自己的方案了。初步思考最核心的矛盾，在于需要修改new创建的实例，但不能要求一行行改造standard的代码。否则，可以在框架中提供一个对象工厂，通过工厂实现在运行时决定创建的实例，甚至可以使用诸如Guice等轻量级的IOC框架来实现，然而用不得。能不能使用动态代理呢？类似在CgLib中就允许使用Dispatch将方法的实现转交由另一个实例执行？依然不行，即使是动态代理依然需要调用端持有代理实例，但没有手段能替换调用端持有的new实例。既然动态代理行不通，静态代理行不行？我们需要在B部门进行项目开发时进行增强，但此时A部门的代码已经编译打包成jar，无法再进行编译阶段的干预，静态代理只能修改B部门的代码，这样做无法解决问题。如此看来，我们需要一种手段，在程序运行阶段进行干预，修改创建的类实例，这似乎需要使用更底层的能力来解决。预研过程直觉上，如果将A类的字节码内容全部替换成B类，就达到我们的目的了，为了达到这个目的需要使用到字节码增强技术。已知的方案是ASM和Javassist两种，其中ASM是在指令层上操作字节码的，代码实现较为晦涩，而Javassist在源码层面操作字节码，并且提供了逐行操作源码的方法，很多功能实现起来就简单得多了。下面我简单介绍下Javassist。JavassistJavassist中，主要有以下几个类： ClassPool: ClassPool用于控制和使用Javassist，它允许我们通过get()方法获取到包含增强功能的CtClass对象。 CtClass: CtClass是Class文件的抽象表示，通过CtClass可以对Class文件进行修改。 CtMethod: 指代了Class中的方法。 CtField: 只带了Class中的属性。先看一个使用示例：ClassPool pool = ClassPool.getDefault();CtClass cc = pool.get(\"com.example.BClass\");cc.setSuperclass(pool.get(\"com.example.AClass\"));cc.writeFile();Java Agent技术首先想到的是Java Agent技术，Classloader技术class文件首先想的是能否直接又暴力地让new A变成new B。最直接的当然是修改运行时的class文件，直觉性的想到应该使用字节码增强，并且与动态代理不同，需要在class文件被加载之前，就修改其内容。针对这个需求，有多种方案，我们一个个分析是否适用于当前业务场景。" }, { "title": "Spring AOP（三）：CgLib代理类详解", "url": "/posts/Spring-AOP-%E4%B8%89-CgLib%E4%BB%A3%E7%90%86%E7%B1%BB%E8%AF%A6%E8%A7%A3/", "categories": "源码阅读, Spring-AOP", "tags": "Java, Spring, AOP, CgLib", "date": "2022-05-04 19:22:12 +0800", "snippet": "前言在上篇文章里将整个AOP加载和执行梳理了一遍，也埋下了个伏笔，CgLibAopProxy对象是通过ProxyFactory创建的，同时后者还调用了getProxy方法获取代理对象实例。1-1 breakpoint getProxy我们在debug时，也经常能看到类变成xxxx$$EnhancerBySpringCGLIB$$xxx的形式：1-2 breakpoint cglib这是因为A...", "content": "前言在上篇文章里将整个AOP加载和执行梳理了一遍，也埋下了个伏笔，CgLibAopProxy对象是通过ProxyFactory创建的，同时后者还调用了getProxy方法获取代理对象实例。1-1 breakpoint getProxy我们在debug时，也经常能看到类变成xxxx$$EnhancerBySpringCGLIB$$xxx的形式：1-2 breakpoint cglib这是因为Autowired注入的对象实际上是代理对象。Spring通过动态代理，生成了代理对象，从而实现AOP功能。这篇文章就来详细看看代理类中究竟有些什么，Spring又是如何创建这个代理类的。实现一个CgLib代理要搞懂原理，首先要会用，第一步先手写一个CgLib代理。引入pom依赖：&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;写一个简单的测试类：class Person { public String name = \"Zeta\"; public void whoAmI(){ System.out.println(\"I'm \" + name); } public void hello(){ System.out.println(\"Hello!\"); }}定义一个方法拦截器，调用目标方法时，CgLib会代理到拦截器上。class PersonHelloInterceptor implements MethodInterceptor { @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { System.out.println(\"say hello...\"); return methodProxy.invokeSuper(o, objects); }}定义一个方法过滤器，accept方法返回值对应callbacks数组的下标class PersonCallbackFilter implements CallbackFilter { @Override public int accept(Method method) { if (method.getName().equals(\"whoAmI\")) { return 1; } return 0; }}Enhancer是字节码增强器，通过它创建代理类并调用方法。public class TestMain { public static void main(String[] args) { System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, \"/temp\"); Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(Person.class); enhancer.setCallback(new PersonHelloInterceptor()); Person proxyPerson = (Person) enhancer.create(); proxyPerson.hello(); proxyPerson.whoAmI(); }}编译并执行，可以看到执行的是被代理过的方法。2-1 cglib democlassFilter上面的例子中使用PersonHelloInterceptor代理了所有的方法，但这通常不是我们的目的，如果只想代理whoAmI()方法该怎么做？为此CgLib提供了classFilter的功能。将代码改成以下形式：public class TestMain { public static void main(String[] args) { System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, \"/temp\"); Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(Person.class); // 添加多个callback enhancer.setCallbacks(new Callback[]{NoOp.INSTANCE, new PersonHelloInterceptor()}); // 配置CallbackFilter，返回值与Callback[]数组下标一一对应 enhancer.setCallbackFilter(new CallbackFilter() { @Override public int accept(Method method) { if (method.getName().equals(\"whoAmI\")) { return 1; } return 0; } }); Person proxyPerson = (Person) enhancer.create(); proxyPerson.hello(); proxyPerson.whoAmI(); }}再次编译执行，这次只通过代理增强了whoAmI()方法2-2 cglib demo classFilterDsipacher除了MethodInterceptor，CgLib还提供了Dsipacher类型的callback,通过它能将方法转交给外部对象执行。先定义一个Dispatcherclass PersonDispatcher implements Dispatcher { private final Person proxy; public PersonDispatcher(Person person) { this.proxy = person; } @Override public Object loadObject(){ return proxy; }}再来个特殊的Personclass Tom extends Person { @Override public void hello() { System.out.println(\"Surprise\"); } @Override public void whoAmI() { System.out.println(\"I'm Tom\"); }}修改测试代码public class TestMain { public static void main(String[] args) { System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, \"/temp\"); Person tom = new Tom(); PersonDispatcher callback = new PersonDispatcher(tom); Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(Person.class); enhancer.setCallback(callback); Person proxyPerson = (Person) enhancer.create(); proxyPerson.hello(); proxyPerson.whoAmI(); }}最终效果如下：2-3 cglib demo dispatch代理类分析通过添加System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, \"/temp\")，可以指定CGLIB将代理类保存至指定路径。将class字节码反编译出来观察结构。静态块首先，代理类继承了原始类，定义了许多成员变量，并且在静态块中进行赋值，不难看出这些变量分别指代了原始方法和代理方法。static { CGLIB$STATICHOOK1();}static void CGLIB$STATICHOOK1() { CGLIB$THREAD_CALLBACKS = new ThreadLocal(); CGLIB$emptyArgs = new Object[0]; // 代理类的Class Class var0 = Class.forName(\"com.zeta.spring.demo.cglib.Person$$EnhancerByCGLIB$$20179872\"); // 原始类的Class Class var1; // 用反射工具获取原始方法 CGLIB$whoAmI$1$Method = ReflectUtils.findMethods(new String[]{\"whoAmI\", \"()V\"}, (var1 = Class.forName(\"com.zeta.spring.demo.cglib.Person\")).getDeclaredMethods())[0]; // 创建代理方法执行器MethodProxy CGLIB$whoAmI$1$Proxy = MethodProxy.create(var1, var0, \"()V\", \"whoAmI\", \"CGLIB$whoAmI$1\");}代理方法调用当通过代理类调用目标方法时，进入的是代理类重写的方法：public final void whoAmI() { // 获取代理拦截器，这里获取的是下标为1的拦截器，也就是PersonHelloInterceptor MethodInterceptor var10000 = this.CGLIB$CALLBACK_1; if (var10000 == null) { CGLIB$BIND_CALLBACKS(this); var10000 = this.CGLIB$CALLBACK_1; } if (var10000 != null) { // 调用拦截器的方法 var10000.intercept(this, CGLIB$whoAmI$1$Method, CGLIB$emptyArgs, CGLIB$whoAmI$1$Proxy); } else { super.whoAmI(); }}原始的方法被包装，methodProxy.invokeSuper调用就是这个方法final void CGLIB$whoAmI$1() { super.whoAmI();}CGLIB$BIND_CALLBACKS - 载入代理拦截器CgLib为每个代理类都创建了静态方法CGLIB$BIND_CALLBACKS，用于获取目标的代理拦截器。可以看到CgLib优先从ThreadLocal中获取拦截器，其次才是初始化时定义的拦截器，说明在未调用任何代理方法前，仍有机会动态修改代理拦截器。private static final void CGLIB$BIND_CALLBACKS(Object var0) { // this Person$$EnhancerByCGLIB$$20179872 var1 = (Person$$EnhancerByCGLIB$$20179872)var0; if (!var1.CGLIB$BOUND) { var1.CGLIB$BOUND = true; Object var10000 = CGLIB$THREAD_CALLBACKS.get(); if (var10000 == null) { var10000 = CGLIB$STATIC_CALLBACKS; if (var10000 == null) { return; } } Callback[] var10001 = (Callback[])var10000; var1.CGLIB$CALLBACK_1 = (MethodInterceptor)((Callback[])var10000)[1]; var1.CGLIB$CALLBACK_0 = (NoOp)var10001[0]; }}其他当然，CgLib的功能还不止这些，例如CgLib提供了一系列构造方法以适应并获取不同的代理实例，又如创建代理类的同时还会创建继承自FastClass的子类用来优化和代替反射调用，更多的细节就待读者深入研究了。Spring中的动态代理从getProxy开始看，虽然代码比较长，但整个逻辑是很清晰的，耐下心​一行行看下去。class CglibAopProxy implements AopProxy, Serializable { @Override public Object getProxy(@Nullable ClassLoader classLoader) { if (logger.isTraceEnabled()) { logger.trace(\"Creating CGLIB proxy: \" + this.advised.getTargetSource()); } try { Class&lt;?&gt; rootClass = this.advised.getTargetClass(); Assert.state(rootClass != null, \"Target class must be available for creating a CGLIB proxy\"); Class&lt;?&gt; proxySuperClass = rootClass; if (rootClass.getName().contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) { proxySuperClass = rootClass.getSuperclass(); Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces(); for (Class&lt;?&gt; additionalInterface : additionalInterfaces) { this.advised.addInterface(additionalInterface); } } // Validate the class, writing log messages as necessary. validateClassIfNecessary(proxySuperClass, classLoader); // Configure CGLIB Enhancer... Enhancer enhancer = createEnhancer(); if (classLoader != null) { enhancer.setClassLoader(classLoader); if (classLoader instanceof SmartClassLoader &amp;&amp; ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) { enhancer.setUseCache(false); } } enhancer.setSuperclass(proxySuperClass); enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised)); enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE); enhancer.setStrategy(new ClassLoaderAwareGeneratorStrategy(classLoader)); Callback[] callbacks = getCallbacks(rootClass); Class&lt;?&gt;[] types = new Class&lt;?&gt;[callbacks.length]; for (int x = 0; x &lt; types.length; x++) { types[x] = callbacks[x].getClass(); } // fixedInterceptorMap only populated at this point, after getCallbacks call above enhancer.setCallbackFilter(new ProxyCallbackFilter( this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset)); enhancer.setCallbackTypes(types); // Generate the proxy class and create a proxy instance. return createProxyClassAndInstance(enhancer, callbacks); } catch (CodeGenerationException | IllegalArgumentException ex) { throw new AopConfigException(\"Could not generate CGLIB subclass of \" + this.advised.getTargetClass() + \": Common causes of this problem include using a final class or a non-visible class\", ex); } catch (Throwable ex) { // TargetSource.getTarget() failed throw new AopConfigException(\"Unexpected AOP exception\", ex); } }}additionalInterfaces通过类名中是否带有$$判断当前类已经是否已经是代理类，如果是则获取其父类的接口添加进advice，后续统一添加给enhancer。初步判断这么做是便于标记，否则通过接口获取实现类(例如BeanFactoryUtils.beanNamesForTypeIncludingAncestors或AutoWired)时需要递归判断会非常麻烦。enhancer.setInterfaces这里通过AopProxyUtils.completeProxiedInterfaces(this.advised)获取接口并配置给代理类，主要有下列几种接口： 代理类的接口，即上一步通过additionalInterfaces获取到的接口。 SpringProxy：必有，用于标记当前类是Spring生成的代理类 Advised：必有，用来保存代理属性，例如前面流程中创建的Advisor、Advise以及代理接口。 DecoratingProxy：仅JDK代理类有，用来获取被代理类的Class类型。那么问题来了，Advised接口是带方法的，但这些方法在被代理类中并没有，Spring是如何添加进去的呢？带着疑问继续往下看。Callback在getCallbacks方法中，Spring创建了一系列Interceptor，并依序组合。Callback[] mainCallbacks = new Callback[] { aopInterceptor, // for normal advice targetInterceptor, // invoke target without considering advice, if optimized new SerializableNoOp(), // no override for methods mapped to this targetDispatcher, this.advisedDispatcher, new EqualsInterceptor(this.advised), new HashCodeInterceptor(this.advised)};... fixedCallbacks[x] = new FixedChainStaticTargetInterceptor( chain, this.advised.getTargetSource().getTarget(), this.advised.getTargetClass());Callbacks分别是： aopInterceptor DynamicAdvisedInterceptor，通用拦截器，会获取所有切面并依次执行，也是前两篇文章中讲解过的拦截器。 targetInterceptor 直接执行目标方法。配置expose-proxy=\"true\"可以将代理类暴露给线程，从而通过AopContext.currentProxy()获取代理类，通常用于解决类内方法调方法时切面失效的问题。 SerializableNoOp 啥也不做，也不会创建对应的拦截器，与CgLib提供的NoOp.INSTANCE相比添加了序列化功能。 targetDispatcher 指向被代理类的Dispatcher advisedDispatcher 指向被advised的Dispatcher EqualsInterceptor Equals方法拦截器。 HashCodeInterceptor HashCode方法拦截器。 fixedCallbacks 当前类为静态类，并且Advice链已冻结时，会用FixedChainStaticTargetInterceptor优化性能。功能与DynamicAdvisedInterceptor完全一致。CallbackFilter紧接着，Spring配置CallbackFilter来决定具体处理方法的Callback，他们遵循以下规则： final类型方法不使用Callback，return 2，即配置为SerializableNoOp。 equals()方法return 5，即配置为EqualsInterceptor。 hashcode()方法return 6，即配置为HashCodeInterceptor。 Advised接口中的方法return 4，即配置为AdvisedDispatcher。还记得前面关于Advised接口方法在代理类中没有实现的疑问吗？从这就能看出，这些方法是通过AdvisedDispatcher分发给了advised对象处理了，从字节码也能看出调用的是advised的方法。 被代理的方法通过advised.getInterceptorsAndDynamicInterceptionAdvice获取当前方法的切面，从而判断方法是否被代理。如果是静态方法并且Advice链已冻结，优化为fixedCallbacks中的回调，否则return 0使用DynamicAdvisedInterceptor。 通过配置expose-proxy=\"true\"暴露代理的方法由于存在切面，同样需要使用DynamicAdvisedInterceptor，以取得链式执行的效果。 未被代理的方法原则上是直接交由被代理方法执行，但要细分几种情况： 暴露代理的非静态方法：return 1，即配置为targetInterceptor。从而保持AopContext的特性。 return this;的方法：由于this是被代理类，如果不做特殊处理，会导致后续的方法调用都无法代理，因此配置为targetInterceptor，后者会将返回值包装为代理对象。 其他方法：return 3，通过targetDispatcher直接交由被代理类执行。 createProxyClassAndInstance最终，通过enhancer.create()完成整个代理类的创建工作。" }, { "title": "Spring AOP（二）：AOP的加载和执行", "url": "/posts/Spring-AOP-%E4%BA%8C-AOP%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/", "categories": "源码阅读, Spring-AOP", "tags": "Java, Spring, AOP, Transation", "date": "2022-04-25 19:05:16 +0800", "snippet": "前言在上篇文章里我们梳理了AOP事务的执行流程，但对于AOP还有许多盲区没有探究。例如前面调试跟踪到的拦截器方法：1-1在堆栈调用链刚进入intercept方法时，代理类从某个池中获取了切面的执行链，就能列出一系列问题： advised对象是何时，从哪里来的，包含哪些内容？ chain是如何被筛选出来的？ AOP执行顺序是如何保证的这一章我们就来梳理AOP逻辑。揭示Intercepto...", "content": "前言在上篇文章里我们梳理了AOP事务的执行流程，但对于AOP还有许多盲区没有探究。例如前面调试跟踪到的拦截器方法：1-1在堆栈调用链刚进入intercept方法时，代理类从某个池中获取了切面的执行链，就能列出一系列问题： advised对象是何时，从哪里来的，包含哪些内容？ chain是如何被筛选出来的？ AOP执行顺序是如何保证的这一章我们就来梳理AOP逻辑。揭示InterceptorChain获取过程当完全不理解一段源码的逻辑时，最需要的就是找到分析的切入点，从图1-1我们可以看得出advised承担了缓存切面监听器Advisor以及筛选当前所需监听器的功能，是个很重要的对象，因此我先选择advised对象来分析。AdvisedSupport的作用首先跳转定义，可以看到advised是AdvisedSupport的实例，查看下运行时参数：2-1 breakpoint advised value虽然大部分参数都不明白意义，但可以看到包含了代理方法的缓存和切面监听器，说明能被切入的方法是在启动时就缓存好的。getInterceptorsAndDynamicInterceptionAdvice从图1-1的调用开始，进入getInterceptorsAndDynamicInterceptionAdvice看看方法逻辑，代码比较长，但阅读源码时一般只要留意入参的使用过程，结合源码注释，就能很快梳理出逻辑，推荐阅读本文的同时自己debug加深理解。public class DefaultAdvisorChainFactory implements AdvisorChainFactory, Serializable { @Override public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(Advised config, Method method, @Nullable Class&lt;?&gt; targetClass) { AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance(); // 1 获取所有已注册的切面监听器 Advisor[] advisors = config.getAdvisors(); List&lt;Object&gt; interceptorList = new ArrayList&lt;&gt;(advisors.length); Class&lt;?&gt; actualClass = (targetClass != null ? targetClass : method.getDeclaringClass()); Boolean hasIntroductions = null; // 2 遍历获取当前方法适用的切面监听器 for (Advisor advisor : advisors) { // 2.1 PointcutAdvisor类型的监听器，自定义切面中最常见的类型 if (advisor instanceof PointcutAdvisor) { PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor; // 2.1.1 先判断监听器是否能处理当前类 if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) { MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher(); boolean match; // 2.1.2 再判断是否能处理当前方法 if (mm instanceof IntroductionAwareMethodMatcher) { if (hasIntroductions == null) { hasIntroductions = hasMatchingIntroductions(advisors, actualClass); } // 2.1.2.1 Introductions的matches match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions); } else { // 2.1.2.1 普通的matches match = mm.matches(method, actualClass); } // 2.1.3 如果能处理就放入执行链列表 if (match) { MethodInterceptor[] interceptors = registry.getInterceptors(advisor); if (mm.isRuntime()) { // Creating a new object instance in the getInterceptors() method // isn't a problem as we normally cache created chains. for (MethodInterceptor interceptor : interceptors) { interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm)); } } else { interceptorList.addAll(Arrays.asList(interceptors)); } } } } // 2.2 IntroductionAdvisor类型的监听器 else if (advisor instanceof IntroductionAdvisor) { IntroductionAdvisor ia = (IntroductionAdvisor) advisor; // 2.2.1 IntroductionAdvisor只作用于类，所以这里只判断能否处理当前类 if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) { Interceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); } } // 2.2 其他类型的监听器，直接加入执行链，等监听器执行时自行判断可用性。 else { Interceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); } } return interceptorList; }}这里遇到了三种类型的Advisor，查阅资料后简单列举下区别： PointcutAdvisor：提供了class+方法的过滤规则，事务切面就是这种类型。 IntroductionAdvisor：提供了class类型的过滤规则。 其他Advisor：其他规则的Advisor，可由用户自定义实现。限于篇幅这里就不继续展开说明matches方法和registry.getInterceptors了，有兴趣的可以继续跟下去看看，简单说说他们功能： matches决定了当前的方法和类能否被处理，是我们在声明切面时实现，而后由Spring包装而成的。具体匹配方法多种多样，例如在事务切面中，是判断方法上是否存在@Transation注解。 registry包含了一些默认的切点，registry.getInterceptors其实是对当前advisor的再次包装，除了获取到当前Advisor的Interceptor，也会判断是否需要把这些默认切点拦截器加入到列表中。阶段总结至此基本了解getInterceptorsAndDynamicInterceptionAdvice的功能了。同时也了解到：Advisor作为SpringAop的顶级接口，负责管理代理拦截器Interceptor、切面过滤器PointCut；AdvisedSupport则负责在运行时管理调度这些Advisor，筛选出当前适用的切面。回过头来，Advised对象包含了所有已知的Advisor，为了了解Advisor如何被创建，下一步是查看advised的加载流程。追踪advised，理解AOP初始化还是从图1-1的线索开始追踪advised，寻找初始化advised对象的地方。由于DynamicAdvisedInterceptor是CglibAopProxy的内部类，并且在Proxy方法中初始化，因此直接给CglibAopProxy的advised变量打上断点，然后启动项目，跟踪堆栈信息：3-1 breakpoint advised首先能看到在CglibAopProxy构造函数中，AdvisedSupport被赋值给了advised3-2 breakpoint proxyInstance往前跟踪堆栈，ProxyFactory创建Proxy实例时，通过判断当前对象是否实现了接口，决定采用CgLib还是Jdk代理，这跟我们通常印象是一致的：3-3 breakpoint createAopProxy从某种意义上讲这一步很关键，请先记住getProxy方法，我会在下一篇文章展开讨论。虽然前面跟踪的都是AopProxy构造方法，但上游调用的实际上是getProxy，ProxyFactory同时完成了创建AopProxy和创建代理对象的功能：3-4 breakpoint getProxy继续跟踪，终于找到了创建advisors对象的地方，但在阅读buildAdvisor源码后可以发现，buildAdvisor获取了Interceptor实例并包装成的对应的Advisor，除此之外没有什么特别之处。于是把阅读源码的重心转移成”了解Interceptor构造过程”。3-5 breakpoint createProxy前面这部分堆栈需要连着看，可以发现一切的源头doCreateBean，Spring在创建完Bean实例后，进行注入成员变量等初始化工作，并调用applyBeanPostProcessors,PostProcessors可以理解为对bean进行特殊处理的包装器，这其中就包含了支撑AOP功能的AbstractAutoProxyCreator。AbstractAutoProxyCreator依据具体情况(是否存在Interceptor)决定是否要将Bean包装成代理对象，并且将代理对象作为结果返回，BeanFactory最终也会将这个代理对象缓存为JavaBean实例。3-6 breakpoint wrapIfNecessary至此，整个AOP初始化的过程就分析完了。追踪Interceptor，理解切面加载和排序了解完AOP的加载过程，继续研究Interceptor初始化，在图3-6中可以看出，Spring调用getAdvicesAndAdvisorsForBean，并依据Interceptor集合是否为空，决定是否创建代理对象。getAdvicesAndAdvisorsForBean存在多种实现，可以在Variable列表中右键this，选择Jump To Type Source：4-1 breakpoint jumpToTypeSource接着点击Ctrl+F12搜索getAdvicesAndAdvisorsForBean，跳转即是当前流程中对应的实现了：4-2 breakpoint search继续跟踪，找到了findEligibleAdvisors方法public abstract class AbstractAdvisorAutoProxyCreator extends AbstractAutoProxyCreator { protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) { List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors(); List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName); extendAdvisors(eligibleAdvisors); if (!eligibleAdvisors.isEmpty()) { eligibleAdvisors = sortAdvisors(eligibleAdvisors); } return eligibleAdvisors; }}findCandidateAdvisors - 获取所有的Advisor一行行来看，首先是findCandidateAdvisors，值得注意的是，AnnotationAwareAspectJAutoProxyCreator是AbstractAdvisorAutoProxyCreator的一种实现，它通过重写了findCandidateAdvisors方法，使得不光可以用实现Advisor接口的方式创建切面(原生的SpringAOP)，也可以用Aspectj的API更简便地声明切面：public class AnnotationAwareAspectJAutoProxyCreator extends AspectJAwareAdvisorAutoProxyCreator { @Override protected List&lt;Advisor&gt; findCandidateAdvisors() { // Add all the Spring advisors found according to superclass rules. List&lt;Advisor&gt; advisors = super.findCandidateAdvisors(); // Build Advisors for all AspectJ aspects in the bean factory. if (this.aspectJAdvisorsBuilder != null) { advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors()); } return advisors; }}原生的SpringAOP通过BeanFactoryAdvisorRetrievalHelper在BeanFactory中查找并获取所有实现了Advisor接口的类，若该类没有创建实例，也会在此时创建：public class BeanFactoryAdvisorRetrievalHelper { public List&lt;Advisor&gt; findAdvisorBeans() { // Determine list of advisor bean names, if not cached already. String[] advisorNames = this.cachedAdvisorBeanNames; if (advisorNames == null) { // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the auto-proxy creator apply to them! // 通过设置allowEagerInit为false，避免获取时过早将对象实例化，早将实例化会导致跳过参数注入的环节 advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors( this.beanFactory, Advisor.class, true, false); this.cachedAdvisorBeanNames = advisorNames; } if (advisorNames.length == 0) { return new ArrayList&lt;&gt;(); } List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;(); for (String name : advisorNames) { if (isEligibleBean(name)) { if (this.beanFactory.isCurrentlyInCreation(name)) { if (logger.isTraceEnabled()) { logger.trace(\"Skipping currently created advisor '\" + name + \"'\"); } } else { try { advisors.add(this.beanFactory.getBean(name, Advisor.class)); } catch (BeanCreationException ex) { Throwable rootCause = ex.getMostSpecificCause(); if (rootCause instanceof BeanCurrentlyInCreationException) { BeanCreationException bce = (BeanCreationException) rootCause; String bceBeanName = bce.getBeanName(); if (bceBeanName != null &amp;&amp; this.beanFactory.isCurrentlyInCreation(bceBeanName)) { if (logger.isTraceEnabled()) { logger.trace(\"Skipping advisor '\" + name + \"' with dependency on currently created bean: \" + ex.getMessage()); } // Ignore: indicates a reference back to the bean we're trying to advise. // We want to find advisors other than the currently created bean itself. continue; } } throw ex; } } } } return advisors; }}aspectJAdvisorsBuilder的查找方法稍微麻烦一些，他取出了所有的JavaBean并筛选出符合两个规则的类 类上带了@Aspect注解 使用了AspectJ的API，但未在编译时创建静态代理的类。这是为了避免重复创建代理类，也是Spring规范性的要求。public class BeanFactoryAspectJAdvisorsBuilder { public List&lt;Advisor&gt; buildAspectJAdvisors() { List&lt;String&gt; aspectNames = this.aspectBeanNames; if (aspectNames == null) { synchronized (this) { aspectNames = this.aspectBeanNames; if (aspectNames == null) { List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;(); aspectNames = new ArrayList&lt;&gt;(); String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors( this.beanFactory, Object.class, true, false); for (String beanName : beanNames) { if (!isEligibleBean(beanName)) { continue; } // We must be careful not to instantiate beans eagerly as in this case they // would be cached by the Spring container but would not have been weaved. Class&lt;?&gt; beanType = this.beanFactory.getType(beanName, false); if (beanType == null) { continue; } if (this.advisorFactory.isAspect(beanType)) { aspectNames.add(beanName); AspectMetadata amd = new AspectMetadata(beanType, beanName); if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) { MetadataAwareAspectInstanceFactory factory = new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName); List&lt;Advisor&gt; classAdvisors = this.advisorFactory.getAdvisors(factory); if (this.beanFactory.isSingleton(beanName)) { this.advisorsCache.put(beanName, classAdvisors); } else { this.aspectFactoryCache.put(beanName, factory); } advisors.addAll(classAdvisors); } else { // Per target or per this. if (this.beanFactory.isSingleton(beanName)) { throw new IllegalArgumentException(\"Bean with name '\" + beanName + \"' is a singleton, but aspect instantiation model is not singleton\"); } MetadataAwareAspectInstanceFactory factory = new PrototypeAspectInstanceFactory(this.beanFactory, beanName); this.aspectFactoryCache.put(beanName, factory); advisors.addAll(this.advisorFactory.getAdvisors(factory)); } } } this.aspectBeanNames = aspectNames; return advisors; } } } }}findAdvisorsThatCanApply - 过滤符合条件的AdvisorfindAdvisorsThatCanApply方法依次取出Advisor的PointCut进行匹配，过滤出符合当前类的Advisorpublic abstract class AopUtils { public static boolean canApply(Advisor advisor, Class&lt;?&gt; targetClass, boolean hasIntroductions) { if (advisor instanceof IntroductionAdvisor) { return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass); } else if (advisor instanceof PointcutAdvisor) { PointcutAdvisor pca = (PointcutAdvisor) advisor; return canApply(pca.getPointcut(), targetClass, hasIntroductions); } else { // It doesn't have a pointcut so we assume it applies. return true; } }}extendAdvisors - 通过其他方式获取Advisor前面是通过findCandidateAdvisors方法从用户代码中获取Advisor，Spring也为Creator提供了一种途径来创建额外的Advisor，例如在AspectJAwareAdvisorAutoProxyCreator中就添加了ExposeInvocationInterceptorpublic abstract class AspectJProxyUtils { public static boolean makeAdvisorChainAspectJCapableIfNecessary(List&lt;Advisor&gt; advisors) { // Don't add advisors to an empty list; may indicate that proxying is just not required if (!advisors.isEmpty()) { boolean foundAspectJAdvice = false; for (Advisor advisor : advisors) { // Be careful not to get the Advice without a guard, as this might eagerly // instantiate a non-singleton AspectJ aspect... if (isAspectJAdvice(advisor)) { foundAspectJAdvice = true; break; } } if (foundAspectJAdvice &amp;&amp; !advisors.contains(ExposeInvocationInterceptor.ADVISOR)) { advisors.add(0, ExposeInvocationInterceptor.ADVISOR); return true; } } return false; }}sortAdvisors - 排序先看代码：public class AspectJAwareAdvisorAutoProxyCreator extends AbstractAdvisorAutoProxyCreator { protected List&lt;Advisor&gt; sortAdvisors(List&lt;Advisor&gt; advisors) { List&lt;PartiallyComparableAdvisorHolder&gt; partiallyComparableAdvisors = new ArrayList&lt;&gt;(advisors.size()); for (Advisor advisor : advisors) { partiallyComparableAdvisors.add( new PartiallyComparableAdvisorHolder(advisor, DEFAULT_PRECEDENCE_COMPARATOR)); } List&lt;PartiallyComparableAdvisorHolder&gt; sorted = PartialOrder.sort(partiallyComparableAdvisors); if (sorted != null) { List&lt;Advisor&gt; result = new ArrayList&lt;&gt;(advisors.size()); for (PartiallyComparableAdvisorHolder pcAdvisor : sorted) { result.add(pcAdvisor.getAdvisor()); } return result; } else { return super.sortAdvisors(advisors); } }}排序的代码比较简单，直接通过Advisor的order属性进行排序，值得注意的是，当两个Advicor的order相同时，队列中靠前的对象会被排到前列，虽然BeanFactoryUtils.beanNamesForTypeIncludingAncestors是无序的，但AnnotationAwareAspectJAutoProxyCreator的findCandidateAdvisors分两步加载原生SpringAOP和AspectJ，注定了原生SpringAOP优先级比AspectJ更高。通过观察BeanFactoryTransactionAttributeSourceAdvisor，可以知道他是继承Advisor实现的切面，并且order是整形最大值，也就是在before中会最先执行。但如果同时又存在其他同类型的切面，就无法保证切面之间事务的有效性了。总结最后，把上面的逻辑整理成流程图，整个AOP创建和使用的过程就一目了然了。" }, { "title": "Spring AOP（一）：从jdbc到Spring Transation", "url": "/posts/Spring-AOP-%E4%B8%80-%E4%BB%8Ejdbc%E5%88%B0Spring-Transation/", "categories": "源码阅读, Spring-AOP", "tags": "Java, Spring, AOP, Transation, Jdbc", "date": "2022-04-22 02:55:15 +0800", "snippet": "前言今天同事提出一套观点： Transation、Druid、jdbc中各有一个autoCommit配置项，相互不影响。 Druid默认设置autoCommit为true。 Spring开启事务时，Spring的autoCommit被设置为false。 由于Spring没有修改Druid的autoCommit状态，JDBC执行方式不受影响，相当于每次查询都是直接提交。 JDBC未开...", "content": "前言今天同事提出一套观点： Transation、Druid、jdbc中各有一个autoCommit配置项，相互不影响。 Druid默认设置autoCommit为true。 Spring开启事务时，Spring的autoCommit被设置为false。 由于Spring没有修改Druid的autoCommit状态，JDBC执行方式不受影响，相当于每次查询都是直接提交。 JDBC未开启事务，每次查询会调用connection.commit()。并得出结论： 要将Druid启动参数中的autoCommit设置为flase，spring事务才会生效。同事的分析过程首先，Druid在初始化时可以配置autoCommit，并且在初始化连接时会配置JDBC的autoCommit。2-1 Druid配置2-2 Druid初始化连接接着，Spring在commit时判断自身状态，仅autoCommit开启时有效。2-3 Spirng commit这样看起来，观点1、观点2都是对的。即使这个结论给的很粗糙，但结合当时在处理问题的情景，对autoCommit的概念又不熟悉，确实很难反驳。但已经隐隐感觉到这个结论有点问题。于是就有了以下的分析。我的分析因为不熟，所以先从AutoCommit的使用开始了解整个过程。JDBC的事务原理我们一般会这么使用JDBC：// 未开启事务Connection conn = DriverManager.getConnection(\"url\", \"user\", \"paasword\")try{ Statement stmt = conn.createStatement(); stmt.execute(\"insert into xxx values ()\");}catch(Exception e){ e.printStackTrace();}finally { conn.close();}// 开启事务Connection conn = DriverManager.getConnection(\"url\", \"user\", \"paasword\")try{ conn.setAutoCommit(false); Statement stmt = conn.createStatement(); stmt.execute(\"insert into xxx values ()\"); conn.commit();}catch(Exception e){ conn.rollback();}finally { conn.close();}要知道，数据库开启事务的方式是使用命令begin，JDBC没有通过API体现出来，说明他通过控制autoCommit的开关，影响了execute方法的执行逻辑。JDBC是一个通用协议，具体的执行由JdbcDriver提供，其实每种驱动实现方式都大同小异，这里展示比较简洁易懂的pgsql驱动代码。private void executeInternal(CachedQuery cachedQuery, @Nullable ParameterList queryParameters, int flags) throws SQLException { this.closeForNextExecution(); if (this.fetchSize &gt; 0 &amp;&amp; !this.wantsScrollableResultSet() &amp;&amp; !this.connection.getAutoCommit() &amp;&amp; !this.wantsHoldableResultSet()) { flags |= 8; } if (this.connection.getAutoCommit()) { flags |= 16; // 0x0000 | 0x0010 = 0x0010 } ... // 中间是一些对flags的赋值和特殊条件下的sql执行，暂且忽略 PgStatement.StatementResultHandler handler = new PgStatement.StatementResultHandler(); synchronized(this) { this.result = null; } try { this.startTimer(); // 调用Executor方法 this.connection.getQueryExecutor().execute(queryToExecute, queryParameters, handler, this.maxrows, this.fetchSize, flags); } finally { this.killTimerTask(); } ... // 一些连接关闭操作，暂且忽略}从java.sql.Statement#execute()一路跟踪调用链，我们找到了org.postgresql.jdbc.PgStatement#executeInternal，虽然不知道flags是什么，但可以看见一段关键代码：开启autoCommit时，flags的第5位标志位被设置为1，然后调用Executor的execute方法执行真正的查询操作。那么接下来只要找到类似判断flags &amp; 16 == 1的地方即可。追踪this.connection.getQueryExecutor().execute不难看出这里就是具体发送sql命令的地方，限于篇幅问题就不再展开讲解了，这里可以进debug看看各个参数的值都是什么，我把关键点在注释里标注出来。public synchronized void execute(Query query, @Nullable ParameterList parameters, ResultHandler handler, int maxRows, int fetchSize, int flags) throws SQLException { this.waitOnLock(); if (LOGGER.isLoggable(Level.FINEST)) { LOGGER.log(Level.FINEST, \" simple execute, handler={0}, maxRows={1}, fetchSize={2}, flags={3}\", new Object[]{handler, maxRows, fetchSize, flags}); } if (parameters == null) { parameters = SimpleQuery.NO_PARAMETERS; } flags = this.updateQueryMode(flags); boolean describeOnly = (32 &amp; flags) != 0; ((V3ParameterList)parameters).convertFunctionOutParameters(); if (!describeOnly) { ((V3ParameterList)parameters).checkAllParametersSet(); } boolean autosave = false; try { try { // autoCommit=ture，并且事务处于预备状态（也就是当前connet还没有执行过），发送begin handler = this.sendQueryPreamble(handler, flags); // autoCommit=ture时，发送savePoint \"SAVEPOINT PGJDBC_AUTOSAVE\" autosave = this.sendAutomaticSavepoint(query, flags); // 执行具体Query this.sendQuery(query, (V3ParameterList)parameters, maxRows, fetchSize, flags, handler, (BatchResultHandler)null); if ((flags &amp; 1024) == 0) { this.sendSync(); } this.processResults(handler, flags); this.estimatedReceiveBufferBytes = 0; } catch (PGBindException var11) { this.sendSync(); this.processResults(handler, flags); this.estimatedReceiveBufferBytes = 0; handler.handleError(new PSQLException(GT.tr(\"Unable to bind parameter values for statement.\", new Object[0]), PSQLState.INVALID_PARAMETER_VALUE, var11.getIOException())); } } catch (IOException var12) { this.abort(); handler.handleError(new PSQLException(GT.tr(\"An I/O error occurred while sending to the backend.\", new Object[0]), PSQLState.CONNECTION_FAILURE, var12)); } try { // handler.handleCompletion(); if (this.cleanupSavePoints) { this.releaseSavePoint(autosave, flags); } } catch (SQLException var10) { // autoCommit=ture时发生异常，回滚到savePoint \"ROLLBACK TO SAVEPOINT PGJDBC_AUTOSAVE\"，并抛出异常 this.rollbackIfRequired(autosave, var10); }}到这一步就很清晰了，JDBC在每次调用execute方法时都去判断是否需要添加begin和savePoint，没有添加commit命令的原因也很简单，假如没有开启事务，数据库只要Query语句就够了；开启事务时，业务需要手动调用commit。SpringManagedTransaction同事没有告诉我他是怎么找到这个类的，代码也跟踪不到这里，尝试使用IDE find usages的功能，也没找到调用端。于是只能先百度下，结果发现，这个类是Mybatis用来实现在Spring中管理多数据源的功能的。所属的包也是org.mybatis.spring.transaction.SpringManagedTransaction。摆了个乌龙，感觉也没必要深入看了。初步结论经过上面分析，可以得出结论观点3、观点5是错误的。反观同事的结论，我们应该配置Druid的AutoCommit状态为false吗？其实思考下就明白不行，这样相当于所有查询都自动加上了conn.setAutoCommit(false)，那一些简单的select方法由于没有手动调用commit，会直接执行异常。观点6也是错误的。但观点4我们还没搞明白：Spring有没有修改Druid的autoCommit状态？是不是每次查询都相当于直接提交？这个问题应该可以在Spring的事务逻辑中找到答案。Spring Transation要跟踪Spring的事务其实很简单，只要写一段demo，debug调试下就能从堆栈中看到了。@RestControllerpublic class SimpleController { @Autowired private SimpleService service; @RequestMapping(\"/tran\") public void tran(){ service.serve(); } }@Servicepublic class SimpleService { @Transactional public void serve(){ System.out.printf(\"hello\"); }}我们在System.out.printf(\"hello\")打个断点观察堆栈。5-1 transaction debug从SimpleController开始，经过Spring创建的代理类，进入了事务切面方法。public abstract class AbstractPlatformTransactionManager implements PlatformTransactionManager, Serializable { @Nullable protected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass, final InvocationCallback invocation) throws Throwable { ... if (txAttr == null || !(ptm instanceof CallbackPreferringPlatformTransactionManager)) { // 创建了一个标准事务 TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification); Object retVal; try { // invoke执行业务方法 retVal = invocation.proceedWithInvocation(); } catch (Throwable ex) { // 异常rollback completeTransactionAfterThrowing(txInfo, ex); throw ex; } finally { cleanupTransactionInfo(txInfo); } if (retVal != null &amp;&amp; vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) { // Set rollback-only in case of Vavr failure matching our rollback rules... TransactionStatus status = txInfo.getTransactionStatus(); if (status != null &amp;&amp; txAttr != null) { retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status); } } // 正常commit commitTransactionAfterReturning(txInfo); return retVal; } }}跟踪createTransactionIfNecessary方法。public abstract class AbstractPlatformTransactionManager implements PlatformTransactionManager, Serializable { protected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm, @Nullable TransactionAttribute txAttr, final String joinpointIdentification) { ... TransactionStatus status = null; if (txAttr != null) { if (tm != null) { // 获取事务 status = tm.getTransaction(txAttr); ... }}public abstract class AbstractPlatformTransactionManager implements PlatformTransactionManager, Serializable { @Override public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException { ... try { // 开启事务 return startTransaction(def, transaction, debugEnabled, suspendedResources); } catch (RuntimeException | Error ex) { resume(null, suspendedResources); throw ex; } ... }}public abstract class AbstractPlatformTransactionManager implements PlatformTransactionManager, Serializable { /** * Start a new transaction. */ private TransactionStatus startTransaction(TransactionDefinition definition, Object transaction, boolean debugEnabled, @Nullable SuspendedResourcesHolder suspendedResources) { boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); DefaultTransactionStatus status = newTransactionStatus( definition, transaction, true, newSynchronization, debugEnabled, suspendedResources); // 找到begin了 doBegin(transaction, definition); prepareSynchronization(status, definition); return status; }}public class DataSourceTransactionManager extends AbstractPlatformTransactionManager implements ResourceTransactionManager, InitializingBean { protected void doBegin(Object transaction, TransactionDefinition definition) { ... if (con.getAutoCommit()) { txObject.setMustRestoreAutoCommit(true); if (this.logger.isDebugEnabled()) { this.logger.debug(\"Switching JDBC Connection [\" + con + \"] to manual commit\"); } con.setAutoCommit(false); } ... }}最终，我们在这里找到了doBegin方法。Spring调用了connect.setAutoCommit(false)，接着就是前面分析过的，JDBC会在第一次执行时发送begin命令。结论Spring没有修改Druid的autoCommit状态，并且跟其他任何的autoCommit配置都无关，因为他会在执行前判断连接的autoCommit状态，如果开启会强制关闭。后续思考至此，我们从JDBC开始到Spring梳理了一遍事务的执行过程，这部分的逻辑还是比较清晰的，关键是要熟练掌握源码阅读的方法和技巧。我们还可以把问题继续问下去：为什么Spring可以这么暴力，直接将autoCommit设置成false，不会有不需要使用事务的场景吗？这个问题涉及到了整个AOP的加载和执行过程，我会在下一篇文章中展开讨论。" } ]
